<!DOCTYPE html>
<html lang="no">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SJAKKARO ‚Äì Avansert partianalyse (patched)</title>
  <!-- Chess libs -->
  <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css" />
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  <style>
    :root {
      --bg:#0b1220; --card:#111a2b; --muted:#aab4cf; --text:#eaf0ff;
      --primary:#4f7cff; --primary-600:#385ff0; --primary-300:#a6bbff;
      --accent:#ffd166; --danger:#ef476f; --ok:#06d6a0;
      --w3:#ff6b35; --w2:#ff8c61; --w1:#ffbe86; --n0:#5e6b8a; --b1:#6ad3e0; --b2:#3bbfd1; --b3:#00a6c8;
      --radius:16px; --shadow:0 10px 30px rgba(0,0,0,.35);
      --board-size:min(88vw,480px); --panel-w:420px; --gap:14px;
    }
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;background:linear-gradient(160deg,#0b1220,#0c1d33 40%,#0b1220 100%);color:var(--text)}
    .app{max-width:1024px;margin:0 auto;padding:16px}
    header.app-head{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:0}
    .brand{font-weight:800;letter-spacing:.3px}.badge{padding:2px 8px;border-radius:999px;background:#1a2640;color:var(--muted);font-size:12px}
    .tabs{display:flex;gap:6px;overflow-x:auto;padding-bottom:6px;margin-bottom:10px}
    .tab{white-space:nowrap;padding:8px 10px;border-radius:10px;background:#0e1730;color:var(--muted);border:1px solid #152243;cursor:pointer;font-weight:600;font-size:13px}
    .tab[aria-selected="true"]{background:var(--primary);color:#fff;border-color:var(--primary-600)}
    .lesson-card{background:var(--card);border-radius:var(--radius);box-shadow:var(--shadow);padding:12px 12px 10px}
    .lesson-grid{display:grid;grid-template-columns:auto var(--panel-w);gap:var(--gap)}
    @media (max-width:760px){:root{--board-size:min(88vw,340px)}.lesson-grid{grid-template-columns:1fr}.panel-toggle{display:inline-flex}.sidepanel{position:fixed;inset:0 0 0 auto;width:min(84vw,320px);transform:translateX(101%);transition:transform .25s ease;z-index:40;background:#0e1730;border-left:1px solid #1d2a4d}.sidepanel.open{transform:translateX(0)}.overlay{position:fixed;inset:0;background:rgba(0,0,0,.5);backdrop-filter:blur(2px);display:none;z-index:30}.overlay.show{display:block}}
    .board-wrap{position:relative;width:var(--board-size);margin:0 auto}
    .board-title{font-weight:700;margin:2px 0 6px;font-size:15px;color:var(--muted)}
    .dkart-overlay{position:absolute;inset:0;pointer-events:none;z-index:5}
    .dk-square{position:absolute;color:#000;font-weight:700;font-size:12px;display:flex;align-items:center;justify-content:center;opacity:.9;border:1px solid rgba(255,255,255,.08)}
    .dk-3{background:var(--w3)} .dk-2{background:var(--w2)} .dk-1{background:var(--w1)} .dk-0{background:var(--n0);color:#fff;opacity:.65} .dk--1{background:var(--b1)} .dk--2{background:var(--b2)} .dk--3{background:var(--b3)}
    .sidepanel{border-radius:12px;background:#0f1a34;padding:10px;height:100%}
    .panel-head{display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:8px}
    .panel-title{font-weight:800;letter-spacing:.2px}
    .move-list{height:160px;overflow:auto;padding-right:6px;border-radius:8px;background:#0c152d;border:1px solid #152243}
    .ply{padding:6px 8px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;display:flex;gap:8px;align-items:center;border-bottom:1px solid #111b37}
    .ply strong{color:var(--muted);width:30px;text-align:right}
    .ply .san{padding:2px 8px;border-radius:6px;background:#0e1730;color:#d5ddff;cursor:pointer}
    .ply .san:hover{background:#152243}
    .ply .san.active{background:var(--primary);color:#fff}
    .ply .eval{font-size:11px;color:var(--muted);margin-left:4px}
    .ply .eval.positive{color:var(--ok)} .ply .eval.negative{color:var(--danger)}
    .action-buttons{display:flex;gap:8px;margin-top:10px}.action-buttons .btn{flex:1}
    .btn{appearance:none;border:1px solid #20315e;background:#0e1730;color:#d9e1ff;padding:8px 10px;border-radius:10px;font-weight:700;cursor:pointer}
    .btn:hover{border-color:#2a3f7b;color:#fff}
    .btn[aria-pressed="true"]{background:var(--primary);border-color:var(--primary-600);color:#fff}
    .btn--primary{background:var(--primary);border-color:var(--primary-600);color:#fff}
    .btn--ghost{opacity:.65}
    .panel-toggle{display:none;gap:6px;align-items:center;border:1px dashed #2a3f7b;background:#0e1730;color:#cfe0ff;padding:6px 8px;border-radius:10px;font-size:13px}
    .modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.8);z-index:1000}
    .modal.show{display:flex;align-items:center;justify-content:center}
    .modal-content{background:var(--card);border-radius:var(--radius);box-shadow:var(--shadow);padding:24px;width:90%;max-width:600px;max-height:80vh;overflow-y:auto}
    .modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px}
    .modal-title{font-size:20px;font-weight:800;color:var(--text)}
    .close-btn{background:none;border:none;font-size:24px;color:var(--muted);cursor:pointer}
    .close-btn:hover{color:var(--text)}
    .modal-section{margin-bottom:20px;padding:16px;border:1px solid #20315e;border-radius:10px}
    .section-title{font-size:16px;font-weight:700;color:var(--primary-300);margin-bottom:12px}
    .form-row{display:flex;gap:12px;margin-bottom:12px}
    .form-group{flex:1}
    .form-label{display:block;font-size:13px;font-weight:600;color:var(--muted);margin-bottom:4px}
    .form-input,.form-select,.form-textarea{width:100%;padding:8px 12px;border:1px solid #20315e;border-radius:8px;background:#0e1730;color:var(--text);font-size:14px}
    .form-input:focus,.form-select:focus,.form-textarea:focus{outline:none;border-color:var(--primary)}
    .form-textarea{resize:vertical;min-height:120px;font-family:ui-monospace,monospace}
    .error-message{background:rgba(239,71,111,.1);border:1px solid var(--danger);color:var(--danger);padding:8px 12px;border-radius:8px;margin-bottom:12px;font-size:13px}
    .loading-message{background:rgba(79,124,255,.1);border:1px solid var(--primary);color:var(--primary);padding:8px 12px;border-radius:8px;margin-bottom:12px;font-size:13px}
    .modal-footer{display:flex;justify-content:flex-end;gap:12px;margin-top:20px;padding-top:16px;border-top:1px solid #20315e}
    .spinner{display:inline-block;width:16px;height:16px;border:2px solid transparent;border-top:2px solid currentColor;border-radius:50%;animation:spin 1s linear infinite;margin-right:8px}
    @keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
    .explain{background:#0f1a34;border:1px solid #1a2a55;border-radius:12px;padding:10px;line-height:1.55;max-height:320px;overflow:auto}

    /* Opening Info Panel Styling */
    .opening-info-panel{background:#0f1a34;border:1px solid #1a2a55;border-radius:12px;padding:12px;font-size:13px;line-height:1.4}
    .opening-header{margin-bottom:10px}
    .opening-name{margin:0 0 4px 0;font-size:14px;font-weight:700;color:var(--primary-300)}
    .opening-meta{display:flex;gap:12px;align-items:center}
    .popularity{color:var(--accent)}
    .difficulty{color:var(--muted);font-size:12px}

    .result-stats{margin:12px 0;padding:8px;background:#0c152d;border-radius:8px}
    .stat-bar{padding:4px 8px;margin:2px 0;border-radius:4px;font-size:12px;font-weight:600;position:relative}
    .stat-bar.white{background:linear-gradient(90deg,var(--ok) 0%,var(--ok) var(--width,0%),transparent var(--width,0%));color:var(--text)}
    .stat-bar.draw{background:linear-gradient(90deg,var(--muted) 0%,var(--muted) var(--width,0%),transparent var(--width,0%));color:var(--text)}
    .stat-bar.black{background:linear-gradient(90deg,var(--danger) 0%,var(--danger) var(--width,0%),transparent var(--width,0%));color:var(--text)}
    .total-games{text-align:center;margin-top:6px;font-size:11px;color:var(--muted)}

    .opening-description{margin:12px 0}
    .character{margin:0 0 8px 0;font-style:italic;color:var(--primary-300)}
    .plans{display:flex;gap:12px;margin-top:8px}
    .white-plans,.black-plans{flex:1}
    .white-plans h5,.black-plans h5{margin:0 0 4px 0;font-size:12px;color:var(--text)}
    .white-plans ul,.black-plans ul{margin:0;padding-left:16px;font-size:11px;color:var(--muted)}
    .white-plans li,.black-plans li{margin-bottom:2px}

    .popular-moves{margin-top:12px}
    .popular-moves h5{margin:0 0 6px 0;font-size:12px;color:var(--text)}
    .move-list{}
    .move-option{display:flex;align-items:center;gap:8px;padding:4px 6px;margin:2px 0;background:#0c152d;border-radius:6px}
    .move-option .move{font-weight:700;color:var(--primary-300);min-width:40px}
    .move-option .percentage{font-size:11px;color:var(--accent);min-width:30px}
    .move-option .desc{font-size:11px;color:var(--muted);flex:1}
    .explain h3{margin:8px 0 4px;font-size:15px;color:var(--primary-300)}
    .gloss{border-bottom:1px dotted var(--accent);cursor:help;position:relative}
    .gloss::after{content:attr(data-def);position:absolute;left:0;top:100%;transform:translateY(6px);white-space:normal;max-width:280px;z-index:10;background:#101a34;color:#eaf0ff;border:1px solid #20315e;padding:8px 10px;border-radius:10px;box-shadow:var(--shadow);opacity:0;pointer-events:none;transition:opacity .15s ease}
    .gloss:hover::after{opacity:1}
    .helpbar{display:flex;gap:8px;flex-wrap:wrap;margin:10px 0}
    .help{font-size:12px;padding:6px 8px;background:#0e1730;border:1px solid #152243;border-radius:999px;color:#bdc8e5}
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}

    /* Puzzle mode highlighting */
    .highlight-yellow{background-color:rgba(255,193,7,0.7) !important;}
    .highlight-green{background-color:rgba(40,167,69,0.7) !important;}
    .highlight-red{background-color:rgba(220,53,69,0.7) !important;}

    /* Opening panel statistics */
    .stats-bar-container {
        display: flex;
        height: 18px;
        border-radius: 4px;
        overflow: hidden;
        background-color: #0c152d;
        border: 1px solid #1a2a55;
        font-size: 10px;
        color: white;
        text-align: center;
    }
    .stats-bar-segment {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
    }
    .stats-bar-white { background-color: var(--ok); }
    .stats-bar-draw { background-color: var(--muted); }
    .stats-bar-black { background-color: var(--danger); }

    .move-stats-line {
        display: grid;
        grid-template-columns: 70px 1fr;
        gap: 8px;
        align-items: center;
        margin-bottom: 4px;
        font-size: 12px;
    }
    .move-stats-line .move-san { font-weight: bold; }
		.eval-graph {
			margin-top: 8px;
			user-select: none;
		}
		.eval-graph svg {
			width: 100%;
			height: 140px;            /* responssiv h√∏yde ‚Äì kan justeres */
			display: block;
		}
		.eval-graph .area-pos { fill: rgba(120, 200, 255, 0.08); }  /* lys felt over 0 */
		.eval-graph .area-neg { fill: rgba(255, 150, 120, 0.08); }  /* lys felt under 0 */
		.eval-graph .curve    { fill: none; stroke: #e8803a; stroke-width: 2; }
		.eval-graph .zero     { stroke: rgba(255,255,255,0.35); stroke-width: 1; }
		.eval-graph .pt       { fill: #e8803a; opacity: 0.0; }      /* punkter skjult (vi bruker tooltip) */
		.eval-graph .pt:hover { opacity: 1; }
		.eval-graph .now      { stroke: rgba(255,255,255,0.5); stroke-width: 1; stroke-dasharray: 4 4; }

		.eval-tooltip {
			position: fixed;
			pointer-events: none;
			z-index: 9999;
			padding: 6px 10px;
			font-size: 12px;
			line-height: 1.25;
			border: 2px solid #0e2a3a;
			background: #eef7ff;
			color: #0e2a3a;
			border-radius: 10px;
			box-shadow: 0 4px 18px rgba(0,0,0,0.25);
			transform: translate(8px, -8px);
			white-space: nowrap;
		}
		@media (prefers-color-scheme: dark) {
			.eval-tooltip {
				background: #0b152a;
				color: #e8f1ff;
				border-color: #0e2a3a;
			}
		}

/* Player Info Panel */
.player-info-panel {
  background: #0c152d;
  border: 1px solid #152243;
  border-radius: 8px;
  padding: 8px 12px;
  margin-bottom: 10px;
  font-size: 14px;
}
.player-line { display: flex; align-items: baseline; gap: 8px; }
.player-line.black { color: var(--muted); }
.player-line .player-name { font-weight: 700; }
.player-line .player-rating { font-size: 12px; color: var(--muted); }
.player-line .player-rating-diff { font-size: 11px; font-weight: bold; }
.player-line .player-rating-diff.positive { color: var(--ok); }
.player-line .player-rating-diff.negative { color: var(--danger); }

/* Game Meta Info in Panel Head */
.game-meta-info { font-size: 13px; color: var(--muted); display: flex; gap: 16px; }
  </style>
</head>
<body>
  <div class="app">
    <header class="app-head">
      <div>
        <div class="brand">‚ôüÔ∏è SJAKKARO</div>
      </div>
      <div class="header-controls">
        <button class="panel-toggle" id="panelToggle" aria-expanded="false">Trekk & analyse ‚ñ∏</button>
        <button class="btn btn--ghost" id="configBtn" title="Konfigurasjon" style="margin-left:8px;">‚öôÔ∏è</button>
      </div>
    </header>

    <nav class="tabs" id="tabs" aria-label="Kategorier">
      <button class="tab" data-c="opening" aria-selected="true">√Öpning</button>
      <button class="tab" data-c="tactics">Taktikk</button>
      <button class="tab" data-c="strategy">Strategi</button>
      <button class="tab" data-c="endgame">Sluttspill</button>
      <button class="tab" data-c="skills">Kjerneferdigheter</button>
    </nav>

    <section class="lesson-card">
      <div class="lesson-grid">
        <div>
          <div class="board-title" id="boardTitle">Last opp parti for analyse</div>
          <div class="board-wrap">
            <div id="board" aria-label="interaktivt sjakkbrett"></div>
            <div class="dkart-overlay" id="dkart" hidden></div>
          </div>

          <div class="explain annotate" id="explainBox">
            <h3>Velkommen til Sjakkaro</h3>
            <p>
              Last opp et parti med PGN-knappen for √• f√• avansert analyse.
              Systemet evaluerer stillinger med <span class="gloss" data-def="Kraftig sjakkmotor for posisjonsvurdering.">Stockfish</span>
              og genererer <span class="gloss" data-def="AI-basert analyse av n√∏kkel√∏yeblikk i partiet.">AI‚Äëcoaching</span>.
            </p>
          </div>

          <div class="chat-panel" id="chatPanel" style="display: none; margin-top: 14px;">
            <div class="chat-history" id="chatHistory" style="background:#0c152d; border:1px solid #1a2a55; border-radius:12px; padding:10px; line-height:1.55; max-height:180px; overflow-y:auto; margin-bottom: 8px;">
              <!-- Meldinger fra chatten vil vises her -->
            </div>
            <div class="chat-input-area" style="display: flex; gap: 8px;">
              <input type="text" id="chatInput" class="form-input" placeholder="Still et sp√∏rsm√•l til AI-coachen...">
              <button class="btn btn--primary" id="chatSendBtn">Send</button>
            </div>
          </div>
        </div>

        <aside class="sidepanel" id="sidepanel" aria-label="Trekk og analyse">
          <div class="panel-head">
            <div class="game-meta-info" id="gameMetaInfo">
              <!-- Dynamisk: Tid/Resultat -->
            </div>
            <div class="nav-buttons">
              <button class="btn btn--ghost" id="btnStart" title="G√• til start (Pil ned)">¬´</button>
              <button class="btn" id="btnPrev" title="Forrige (‚Üê)">‚Üê</button>
              <button class="btn" id="btnNext" title="Neste (‚Üí)">‚Üí</button>
              <button class="btn btn--ghost" id="btnEnd" title="G√• til siste trekk">¬ª</button>
            </div>
          </div>

          <!-- Player Info Panel -->
          <div class="player-info-panel" id="playerInfoPanel" style="display: none;">
            <div class="player-line white">
              <span class="player-name" id="whitePlayerName"></span>
              <span class="player-rating" id="whitePlayerRating"></span>
              <span class="player-rating-diff" id="whitePlayerRatingDiff"></span>
            </div>
            <div class="player-line black">
              <span class="player-name" id="blackPlayerName"></span>
              <span class="player-rating" id="blackPlayerRating"></span>
              <span class="player-rating-diff" id="blackPlayerRatingDiff"></span>
            </div>
          </div>

          <div class="move-list" id="moveList" role="list" aria-live="polite"></div>
					<div id="evalGraph" class="eval-graph" aria-label="Evalueringsgraf"></div>

          <div class="action-buttons" aria-label="Verkt√∏y">
            <button class="btn" id="btnDkart" aria-pressed="false">Dkart</button>
            <button class="btn" id="btnAnalyze">Lichess</button>
            <button class="btn btn--primary" id="btnPGN">PGN</button>
          </div>

          <!-- √Öpningsinfo-panel -->
          <div class="opening-info-panel" id="openingInfoPanel" style="display:none;">
              <h4 class="opening-name" id="openingName">√Öpningsnavn</h4>
              <div id="openingStatsContainer">
                  <!-- Dynamisk innhold lastes her -->
              </div>
              <div class="opening-description" id="openingDescription">
                  <p id="aiOpeningText">AI-generert beskrivelse lastes her...</p>
              </div>
          </div>
        </aside>
      </div>
    </section>
  </div>

  <!-- Configuration Modal -->
  <div class="modal" id="configModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">‚öôÔ∏è Konfigurasjon</h2>
        <button class="close-btn" id="closeConfigModal">&times;</button>
      </div>

      <div class="modal-section">
        <div class="section-title">ü§ñ Stockfish Motor</div>
        <div class="helpbar">
          <span class="help">Modus:
            <label><input type="radio" name="mode" value="movetime" checked> tid</label>
            <label><input type="radio" name="mode" value="depth"> dybde</label>
          </span>
          <span class="help">ms/trekk: <input id="mtInput" type="number" min="200" max="5000" step="100" value="1500" style="width:80px"></span>
          <span class="help">Depth: <input id="depthInput" type="number" min="8" max="24" value="18" style="width:60px"></span>
          <span class="help">MultiPV: <input id="mpvInput" type="number" min="1" max="5" value="3" style="width:50px"></span>
        </div>
      </div>

      <div class="modal-section">
        <div class="section-title">üìö √Öpningsbok (Lichess)</div>
        <div class="helpbar">
          <span class="help">√Öpningsbok: <input type="checkbox" id="openingEnabled" checked></span>
          <span class="help">Strategi:
            <select id="openingStrategy" style="width:80px;font-size:11px;">
              <option value="balanced" selected>Balansert</option>
              <option value="popular">Popul√¶r</option>
              <option value="performance">Resultat</option>
              <option value="random">Tilfeldig</option>
            </select>
          </span>
          <span class="help">Min partier: <input id="minGamesInput" type="number" min="50" max="1000" step="50" value="100" style="width:60px"></span>
          <span class="help">Max trekk: <input id="maxPliesInput" type="number" min="10" max="40" step="5" value="20" style="width:50px"></span>
        </div>
      </div>

      <!-- AI-innstillinger -->
      <div class="modal-section">
        <div class="section-title">ü§ñ AI</div>

        <div class="form-group">
          <label class="form-label" for="aiModelSelector">Velg AI-modell</label>
          <select id="aiModelSelector" class="form-select"></select>
        </div>

        <div class="form-group">
          <label class="form-label" for="geminiApiKeyInput">Gemini API-n√∏kkel</label>
          <input id="geminiApiKeyInput" type="password" class="form-input" placeholder="Lim inn n√∏kkel her">
        </div>

        <div class="form-group">
          <label class="form-label" for="groqApiKeyInput">Groq API-n√∏kkel</label>
          <input id="groqApiKeyInput" type="password" class="form-input" placeholder="Lim inn n√∏kkel her">
        </div>

        <small>Tips: N√∏klene lagres lokalt i nettleseren (localStorage) p√• denne maskinen.</small>
      </div>

      <div class="modal-footer">
        <button class="btn" id="resetConfigBtn">Tilbakestill</button>
        <button class="btn btn--primary" id="saveConfigBtn">Lagre</button>
      </div>
    </div>
  </div>

  <!-- PGN Modal -->
  <div class="modal" id="pgnModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">üì• Last opp parti</h2>
        <button class="close-btn" id="closeModal">&times;</button>
      </div>

      <div id="errorMessage" class="error-message" style="display:none"></div>
      <div id="loadingMessage" class="loading-message" style="display:none"></div>

      <div class="modal-section">
        <div class="section-title">üìã Fra Lichess</div>
        <div class="form-row">
          <div class="form-group">
            <label class="form-label" for="lichessUsername">Brukernavn</label>
            <input type="text" id="lichessUsername" class="form-input" placeholder="@olanord" />
          </div>
          <div class="form-group">
            <label class="form-label" for="numGames">Antall</label>
            <input type="number" id="numGames" class="form-input" min="1" value="1" />
          </div>
        </div>
        <button class="btn btn--primary" id="fetchLichessBtn">Hent partier fra Lichess</button>
      </div>

      <div class="modal-section">
        <div class="section-title">üìÅ Fra fil</div>
        <input type="file" id="pgnFile" accept=".pgn" style="display:none" />
        <button class="btn btn--primary" id="loadFileBtn">Last opp fra fil</button>
      </div>

      <div class="modal-section" id="gameSelectSection" style="display:none">
        <div class="section-title">Velg parti</div>
        <div class="form-group">
          <label class="form-label" for="gameSelect">Velg parti</label>
          <select id="gameSelect" class="form-select"></select>
        </div>
        <button class="btn btn--primary" id="selectGameBtn">Last valgt parti</button>
      </div>

      <div class="modal-section">
        <div class="section-title">‚úèÔ∏è Lim inn PGN</div>
        <div class="form-group">
          <label class="form-label" for="pgnText">PGN-data</label>
          <textarea id="pgnText" class="form-textarea" placeholder="Lim inn PGN her..."></textarea>
        </div>
        <button class="btn btn--primary" id="loadTextBtn">Last parti fra tekst</button>
      </div>

      <div class="modal-footer">
        <button class="btn" id="cancelBtn">Avbryt</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="overlay"></div>

  <script>
    /*********************
     * STATE
     *********************/
    const openingTextCache = new Map();
    let current='opening', board, game, sanList=[], idx=0, dkOn=false;
    let evaluations=[], loadedGame=null, engine=null, analysisResolver=null, lastInfo={score:null,depth:null,pv:null};
    let enhancedEvals=[], gameOpeningInfo=null; // Lagrer utvidet evalueringsdata og √•pningsinfo
    let fileGameList=[];

    // Puzzle system variables
    let allPuzzles = [];
    let isInPuzzleMode = false;
    let currentPuzzle = null;
    let puzzleSolutionMoves = [];
    let currentPuzzleStep = 0;
    let savedAnalysisFEN = '';
    let chatHistory = [];
    let selectedOpeningDb = 'lichess';
    const SERVER_URL='http://localhost:8080';

    // === API-keys i localStorage (ingen backend) ===
    function getGeminiApiKey() {
      return localStorage.getItem('geminiApiKey') ?? '';
    }
    function setGeminiApiKey(k) {
      localStorage.setItem('geminiApiKey', (k || '').trim());
    }
    function getGroqApiKey() {
      return localStorage.getItem('groqApiKey') ?? '';
    }
    function setGroqApiKey(k) {
      localStorage.setItem('groqApiKey', (k || '').trim());
    }

    // === Provider-tabell (kan utvides) ===
    const AI_PROVIDERS = {
      'gemini-2.5-flash-lite': {
        name: 'Gemini 2.5 Flash-Lite',
        provider: 'gemini',
        getApiKey: getGeminiApiKey,
        handler: callGeminiAPI
      },
      'deepseek-r1-distill-llama-70b': {
        name: 'Groq DeepSeek-R1 (70B)',
        provider: 'groq',
        getApiKey: getGroqApiKey,
        handler: callGroqAPI
      }
    };

    // === Aktiv modell (med persistens) ===
    let currentAIModel = localStorage.getItem('aiModel') ?? 'gemini-2.5-flash-lite';
    function setCurrentAIModel(key) {
      currentAIModel = key;
      localStorage.setItem('aiModel', key);
    }

    // ---- Lichess Opening Book Configuration ----
    const OPENING_BOOK = {
      enabled: true,
      maxPlies: 60,        // Bruk √•pningsbok kun de f√∏rste 30 halvtrekkene
      minGames: 1,       // Minimum antall partier for √• bruke bokdata
      speeds: 'blitz,rapid,classical',
      ratings: '1600,1800,2000,2200',
      strategy: 'balanced'  // 'popular', 'performance', 'balanced', 'random'
    };

    // Opening book cache
    const openingCache = new Map();
    const maxCacheSize = 500;
    const cacheExpiry = 24 * 60 * 60 * 1000; // 24 timer
    let lastOpeningQuery = 0; // Rate limiting

    // Wikibooks cache for translated content
    const wikibooksCache = new Map();
    const wikibooksCacheExpiry = 7 * 24 * 60 * 60 * 1000; // 1 uke

    // oppdagede UCI-opsjoner
    const engineCaps = { threads:false, options:{} };

    // bruker‚Äëvalg for motor
    function getEnginePrefs(){
      const mode = document.querySelector('input[name="mode"]:checked')?.value||'movetime';
      const ms = Math.max(2000, parseInt(document.getElementById('mtInput').value||'3000',10)); // √òkt tid for stabilitet
      const depth = Math.max(15, parseInt(document.getElementById('depthInput').value||'20',10)); // √òkt dybde
      const mpv = 1; // Kun beste trekk for Lichess-kompatibilitet
      return { mode, ms, depth, mpv };
    }

    function updateOpeningBookConfig() {
      OPENING_BOOK.enabled = document.getElementById('openingEnabled')?.checked ?? true;
      OPENING_BOOK.strategy = document.getElementById('openingStrategy')?.value || 'balanced';
      OPENING_BOOK.minGames = Math.max(50, parseInt(document.getElementById('minGamesInput')?.value || '100', 10));
      OPENING_BOOK.maxPlies = Math.max(10, parseInt(document.getElementById('maxPliesInput')?.value || '20', 10));

      console.log('Opening book config updated:', OPENING_BOOK);
    }

    /********************* PGN Evaluation Detection & Extraction *********************/
    function hasEvaluations(pgnText) {
      // Sjekk om PGN inneholder [%eval] tags
      return /\[%eval\s+[+-]?(?:\d+\.?\d*|#[+-]?\d+)\]/.test(pgnText);
    }

    function extractEvaluationsFromPGN(pgnText) {
      const evals = [];
      const evalRegex = /\[%eval\s+([+-]?(?:\d+\.?\d*|#[+-]?\d+))\]/g;
      let match;

      console.log('Extracting evaluations from PGN...');

      while ((match = evalRegex.exec(pgnText)) !== null) {
        const evalStr = match[1];
        console.log(`Found eval: ${evalStr}`);

        // H√•ndter mate-evalueringer (#5, #-3, etc.)
        if (evalStr.startsWith('#')) {
          evals.push(evalStr); // Behold mate-format
        } else {
          // Numeriske evalueringer - formater med + for positive verdier
          const num = parseFloat(evalStr);
          if (!isNaN(num)) {
            evals.push(num >= 0 ? `+${num.toFixed(2)}` : num.toFixed(2));
          }
        }
      }

      console.log(`Extracted ${evals.length} evaluations:`, evals);
      return evals;
    }

    function alignEvaluationsWithMoves(extractedEvals, moveCount) {
      // PGN evalueringer starter ofte etter f√∏rste trekk
      // Vi trenger evaluering for startposisjon (0.00) + alle posisjoner etter trekk
      const alignedEvals = ['0.00']; // Startposisjon

      // Kopier ekstraherte evalueringer
      for (let i = 0; i < moveCount && i < extractedEvals.length; i++) {
        alignedEvals.push(extractedEvals[i]);
      }

      // Hvis vi mangler evalueringer p√• slutten, bruk siste kjente verdi
      while (alignedEvals.length <= moveCount) {
        const lastEval = alignedEvals[alignedEvals.length - 1];
        alignedEvals.push(lastEval);
      }

      console.log(`Aligned ${alignedEvals.length} evaluations for ${moveCount} moves`);
      return alignedEvals;
    }

    function showEvaluationSource(source) {
        const panelTitle = document.querySelector('.panel-title');
        if (panelTitle) {
            panelTitle.textContent = 'Trekk';
        }
    }

    /********************* Lichess Opening Book API *********************/
    async function queryLichessOpeningBook(fen) {
      if (!OPENING_BOOK.enabled) return null;

      // Sjekk cache f√∏rst
      const cacheKey = `${fen}-${selectedOpeningDb}`;
      if (openingCache.has(cacheKey)) {
        const cached = openingCache.get(cacheKey);
        if (Date.now() - cached.timestamp < cacheExpiry) {
          console.log('Using cached opening data for', cacheKey);
          return cached.data;
        } else {
          openingCache.delete(cacheKey);
        }
      }

      // Rate limiting - vente minst 1 sekund mellom foresp√∏rsler
      const now = Date.now();
      const timeSinceLastQuery = now - lastOpeningQuery;
      if (timeSinceLastQuery < 1000) {
        await new Promise(resolve => setTimeout(resolve, 1000 - timeSinceLastQuery));
      }
      lastOpeningQuery = Date.now();

      try {
        const baseUrl = `https://explorer.lichess.ovh/${selectedOpeningDb}`;
        const params = new URLSearchParams({
          variant: 'standard',
          fen: fen,
          speeds: OPENING_BOOK.speeds,
          ratings: OPENING_BOOK.ratings,
          moves: '10',
          topGames: '0',
          recentGames: '0'
        });

        // Note: We use the FEN which already represents the position after moves.
        // No need for 'play' parameter when using FEN.

        console.log(`Querying Lichess opening book: ${baseUrl}?${params}`);
        const response = await fetch(`${baseUrl}?${params}`);

        if (!response.ok) {
          throw new Error(`Lichess API error: ${response.status}`);
        }

        const data = await response.json();

        // Beregn statistikk for trekkene
        if (data.moves) {
          data.moves = data.moves.map(move => {
            const total = (move.white || 0) + (move.draws || 0) + (move.black || 0);
            const winRate = total > 0 ? (move.white || 0) / total : 0;
            const drawRate = total > 0 ? (move.draws || 0) / total : 0;
            const performance = winRate * 1.0 + drawRate * 0.5; // Performance score
            return {
              ...move,
              total,
              winRate,
              drawRate,
              performance
            };
          });
        }

        // Cache resultatet
        if (openingCache.size >= maxCacheSize) {
          // Fjern eldste cache-entry
          const firstKey = openingCache.keys().next().value;
          openingCache.delete(firstKey);
        }
        openingCache.set(cacheKey, {
          data,
          timestamp: Date.now()
        });

        console.log('Lichess opening data retrieved with', data.moves?.length || 0, 'moves');
        return data;
      } catch (error) {
        console.error('Error querying Lichess opening book:', error);
        return null;
      }
    }

    function calculateOpeningEvaluation(bookData) {
      if (!bookData || !bookData.moves || bookData.moves.length === 0) return null;

      // Beregn gjennomsnittlig performance basert p√• alle trekk
      const totalGames = bookData.moves.reduce((sum, move) => sum + move.total, 0);
      if (totalGames < OPENING_BOOK.minGames) return null;

      const weightedPerformance = bookData.moves.reduce((sum, move) => {
        return sum + (move.performance * move.total);
      }, 0) / totalGames;

      // Konverter performance til centipawn-lignende score
      // 0.5 = jevnt (0.00), 0.6 = +hvit (+50), 0.4 = +svart (-50)
      const centipawns = (weightedPerformance - 0.5) * 100;
      return centipawns >= 0 ? `+${centipawns.toFixed(2)}` : centipawns.toFixed(2);
    }

    function selectBestOpeningMove(bookData) {
      if (!bookData || !bookData.moves || bookData.moves.length === 0) return null;

      const moves = bookData.moves.filter(m => m.total >= 10); // Filtrer sjeldne trekk
      if (!moves.length) return bookData.moves[0];

      switch (OPENING_BOOK.strategy) {
        case 'popular':
          return moves.sort((a, b) => b.total - a.total)[0];

        case 'performance':
          return moves.sort((a, b) => b.performance - a.performance)[0];

        case 'balanced':
          // Kombiner popularitet (30%) og performance (70%)
          const scored = moves.map(m => ({
            ...m,
            score: (m.total / Math.max(...moves.map(x => x.total))) * 0.3 + m.performance * 0.7
          }));
          return scored.sort((a, b) => b.score - a.score)[0];

        case 'random':
          // Vektet tilfeldig basert p√• performance
          const weights = moves.map(m => Math.max(0.1, m.performance * Math.sqrt(m.total)));
          const totalWeight = weights.reduce((sum, w) => sum + w, 0);
          const rand = Math.random() * totalWeight;
          let cumulative = 0;
          for (let i = 0; i < moves.length; i++) {
            cumulative += weights[i];
            if (rand <= cumulative) return moves[i];
          }
          return moves[0];

        default:
          return moves.sort((a, b) => b.total - a.total)[0];
      }
    }

    /********************* Wikibooks Integration *********************/
    function formatMovesForWikibooks(moves) {
      // Konverter ["e4", "e5", "Nf3", "Nc6"] til "1._e4/1...e5/2._Nf3/2...Nc6"
      let formatted = "";
      for (let i = 0; i < moves.length; i += 2) {
        const moveNum = Math.floor(i / 2) + 1;
        formatted += `${moveNum}._${moves[i]}`;
        if (moves[i + 1]) {
          formatted += `/${moveNum}...${moves[i + 1]}`;
        }
        if (i + 2 < moves.length) formatted += "/";
      }
      return formatted;
    }

    async function fetchWikibooksOpening(moveSequence) {
      if (!moveSequence || moveSequence.length === 0) return null;

      try {
        // Konverter trekk til Wikibooks URL-format
        const urlPath = formatMovesForWikibooks(moveSequence);
        const wikiUrl = `Chess_Opening_Theory/${urlPath}`;

        console.log(`Fetching Wikibooks: ${wikiUrl}`);

        // Bruk Wikipedia API for √• hente Wikibooks-innhold
        const apiUrl = `https://en.wikibooks.org/w/api.php?action=query&format=json&origin=*&prop=extracts&exintro&explaintext&titles=${encodeURIComponent(wikiUrl)}`;

        const response = await fetch(apiUrl);
        if (!response.ok) throw new Error(`Wikibooks API error: ${response.status}`);

        const data = await response.json();
        const pages = data.query?.pages;

        if (!pages) return null;

        const pageId = Object.keys(pages)[0];
        const page = pages[pageId];

        if (page.missing) {
          console.log(`Wikibooks page not found: ${wikiUrl}`);
          return null;
        }

        return {
          title: page.title,
          extract: page.extract,
          url: `https://en.wikibooks.org/wiki/${wikiUrl.replace(/ /g, '_')}`
        };

      } catch (error) {
        console.error('Wikibooks fetch error:', error);
        return null;
      }
    }

    async function loadChessDictionary() {
      try {
        const response = await fetch('/docs/norsk_sjakk_ordbok.csv');
        if (!response.ok) throw new Error('Could not load chess dictionary');

        const csvText = await response.text();
        const lines = csvText.split('\n');
        const translations = [];

        // Parse CSV (skip header)
        for (let i = 2; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;

          // Simple CSV parsing - kan forbedres ved behov
          const match = line.match(/^"?([^"]+)"?\s+"[^"]*"\s+"[^"]*"\s+"?([^"]*)"?$/);
          if (match) {
            const norwegianTerm = match[1].trim();
            const englishNote = match[2].trim();

            // Trekk ut engelske termer fra "Falsk Venn"-kolonnen
            if (englishNote && englishNote !== 'undefined') {
              const englishTerms = englishNote.match(/[A-Z][a-z]+/g);
              if (englishTerms) {
                englishTerms.forEach(eng => {
                  translations.push(`${eng} ‚Üí ${norwegianTerm}`);
                });
              }
            }
          }
        }

        return translations.slice(0, 50).join('\n'); // Begrens til de viktigste termene

      } catch (error) {
        console.error('Dictionary loading error:', error);
        // Fallback til hard-kodet viktige termer
        return `Opening ‚Üí √Öpning
Defense ‚Üí Forsvar
Attack ‚Üí Angrep
Control ‚Üí Kontroll
Development ‚Üí Utvikling
Center ‚Üí Sentrum
Piece ‚Üí Brikke
Pawn ‚Üí Bonde
Knight ‚Üí Springer
Bishop ‚Üí L√∏per
Rook ‚Üí T√•rn
Queen ‚Üí Dronning
King ‚Üí Konge
Gambit ‚Üí Gambit
Strategy ‚Üí Strategi
Tactics ‚Üí Taktikk`;
      }
    }

    async function translateOpeningInfo(englishContent) {
      if (!englishContent) return englishContent;

      try {
        const dictionary = await loadChessDictionary();

        const prompt = `Oversett f√∏lgende sjakk√•pningsinformasjon til norsk. Bruk den vedlagte norske sjakkordboken for korrekte fagtermer.

VIKTIGE OVERSETTELSESREGLER:
${dictionary}

Oversett til naturlig norsk, men behold sjakkfaglige termer korrekt. Fokuser p√•:
1. √Öpningskarakteristikk og spillestil
2. Typiske planer for hvit og svart
3. Vanlige feller og taktiske motiver
4. Pedagogiske r√•d

Tekst som skal oversettes:
${englishContent.substring(0, 1000)} // Begrens lengde

Returner kun den oversatte teksten uten ekstra kommentarer.`;

        const translatedText = await getAICompletion(prompt);

        return translatedText || englishContent;

      } catch (error) {
        console.error('Translation error:', error);
        return englishContent; // Fallback til engelsk
      }
    }

    async function getOpeningTheory(moveSequence) {
      if (!moveSequence || moveSequence.length === 0) return null;

      const cacheKey = moveSequence.join('_');

      // Sjekk cache f√∏rst
      if (wikibooksCache.has(cacheKey)) {
        const cached = wikibooksCache.get(cacheKey);
        if (Date.now() - cached.timestamp < wikibooksCacheExpiry) {
          console.log('Using cached Wikibooks data for', cacheKey);
          return cached.data;
        }
      }

      try {
        // Hent fra Wikibooks
        const wikiContent = await fetchWikibooksOpening(moveSequence);
        if (!wikiContent) return null;

        // Oversett til norsk
        const translatedContent = await translateOpeningInfo(wikiContent.extract);

        const result = {
          ...wikiContent,
          translatedExtract: translatedContent,
          character: extractOpeningCharacter(translatedContent),
          plans: extractPlans(translatedContent)
        };

        // Cache resultatet
        if (wikibooksCache.size >= maxCacheSize) {
          const firstKey = wikibooksCache.keys().next().value;
          wikibooksCache.delete(firstKey);
        }

        wikibooksCache.set(cacheKey, {
          data: result,
          timestamp: Date.now()
        });

        console.log('Wikibooks theory loaded and translated for', cacheKey);
        return result;

      } catch (error) {
        console.error('Opening theory fetch error:', error);
        return null;
      }
    }

    function extractOpeningCharacter(text) {
      // Enkel parsing for √• finne √•pningskarakteristikk
      const sentences = text.split('. ').slice(0, 2);
      return sentences.join('. ') + (sentences.length > 0 ? '.' : '');
    }

    function extractPlans(text) {
      // Enkel parsing for √• finne planer (kan forbedres)
      const whitePlans = [];
      const blackPlans = [];

      // Look for common plan indicators
      const whiteKeywords = ['hvit', 'white', 'first player'];
      const blackKeywords = ['svart', 'black', 'second player'];

      const sentences = text.toLowerCase().split('.');

      sentences.forEach(sentence => {
        if (whiteKeywords.some(kw => sentence.includes(kw))) {
          if (sentence.length < 100 && sentence.length > 10) {
            whitePlans.push(sentence.trim());
          }
        } else if (blackKeywords.some(kw => sentence.includes(kw))) {
          if (sentence.length < 100 && sentence.length > 10) {
            blackPlans.push(sentence.trim());
          }
        }
      });

      return {
        white: whitePlans.slice(0, 3),
        black: blackPlans.slice(0, 3)
      };
    }

    /********************* Chat Functions *********************/
    // NYE FUNKSJONER FOR CHAT

    // Hovedfunksjon for √• h√•ndtere sending av meldinger
    async function handleChatMessage() {
        const chatInput = document.getElementById('chatInput');
        const userMessage = chatInput.value.trim();
        if (!userMessage) return;

        appendMessageToChat(userMessage, 'user');
        chatInput.value = '';
        showLoadingInChat();

        // Samle all n√∏dvendig kontekst
        const currentFEN = game.fen();
        const whitePlayer = loadedGame.white || 'Hvit';
        const blackPlayer = loadedGame.black || 'Svart';

        // Legg til brukerens melding i historikken
        chatHistory.push({ role: 'user', content: userMessage });

        // Hent svar fra AI med full kontekst
        const response = await getAIChatResponse(chatHistory, currentFEN, whitePlayer, blackPlayer);

        // Legg til AI-ens svar i historikken
        chatHistory.push({ role: 'ai', content: response });

        removeLoadingFromChat();
        appendMessageToChat(response, 'ai');
    }

    // Funksjon for √• kalle Gemini API for et chat-svar
    async function getAIChatResponse(chatHistory, currentFEN, whitePlayer, blackPlayer) {
        try {
            const analysisContext = document.getElementById('explainBox').innerText;

            // Formater chat-historikken for prompten
            const formattedHistory = chatHistory.map(msg =>
                `${msg.role === 'user' ? 'Elev' : 'Sjakkaro'}: ${msg.content}`
            ).join('\n');

            // Dette er den nye, forbedrede Prompt0
            const chatPrompt = `ROLLE OG M√ÖL
Du er AI-sjakktreneren Sjakkaro. Din personlighet er ekspert, pedagogisk og oppmuntrende. Du er i en samtale med en ungdomsskoleelev om et sjakkparti de har spilt.

KONTEKST FOR SAMTALEN
-   **Partianalyse:** Du har allerede gitt eleven f√∏lgende analyse:\n---ANALYSE---\n${analysisContext}\n---SLUTT P√Ö ANALYSE---
-   **Spillere:** Partiet ble spilt mellom ${whitePlayer} (Hvit) og ${blackPlayer} (Svart).
-   **N√•v√¶rende Stilling:** Eleven ser n√• p√• stillingen representert ved denne FEN-strengen: \`${currentFEN}\`. Du M√Ö bruke denne stillingen som utgangspunkt for svaret ditt.
-   **Samtalehistorikk:** Her er den p√•g√•ende samtalen:\n${formattedHistory}

OPPGAVE
Svar p√• elevens siste melding. V√¶r kortfattet, pedagogisk og motiverende. Bruk norsk sjakkterminologi. Fortsett samtalen med din etablerte "Sjakkaro"-personlighet.`;

            return await getAICompletion(chatPrompt);
        } catch (e) {
            console.error('Chat error:', e);
            return "Beklager, jeg klarte ikke √• behandle sp√∏rsm√•let ditt akkurat n√•.";
        }
    }

    // Hjelpefunksjoner for √• oppdatere chat-vinduet
    function appendMessageToChat(message, sender) {
        const chatHistory = document.getElementById('chatHistory');
        const messageDiv = document.createElement('div');
        messageDiv.style.marginBottom = '10px';
        messageDiv.innerHTML = `<strong>${sender === 'user' ? 'Du' : 'AI-Coach'}:</strong><br>${message.replace(/\n/g, '<br>')}`;
        chatHistory.appendChild(messageDiv);
        chatHistory.scrollTop = chatHistory.scrollHeight; // Scroll til bunnen
    }

    function showLoadingInChat() {
        const chatHistory = document.getElementById('chatHistory');
        const loadingDiv = document.createElement('div');
        loadingDiv.id = 'chatLoading';
        loadingDiv.innerHTML = `<span class="spinner"></span> AI-coachen tenker...`;
        chatHistory.appendChild(loadingDiv);
        chatHistory.scrollTop = chatHistory.scrollHeight;
    }

    function removeLoadingFromChat() {
        const loadingDiv = document.getElementById('chatLoading');
        if (loadingDiv) loadingDiv.remove();
    }

    /********************* AI Abstraction Layer *********************/
    // Sentralt inngangspunkt for all AI-kommunikasjon
    async function getAICompletion(prompt, opts = {}) {
      const provider = AI_PROVIDERS[currentAIModel];
      if (!provider) return `Feil: AI-leverand√∏r '${currentAIModel}' ikke funnet.`;

      const apiKey = provider.getApiKey();
      if (!apiKey) return 'Mangler API-n√∏kkel for valgt AI-leverand√∏r. √Öpne innstillinger og legg inn n√∏kkelen.';

      try {
        return await provider.handler(prompt, currentAIModel, apiKey, opts);
      } catch (e) {
        console.error(`Error with AI provider ${currentAIModel}:`, e);
        return `Det oppstod en feil med AI-tjenesten (${currentAIModel}).`;
      }
    }

    // Adapter: Gemini API
    async function callGeminiAPI(prompt, modelId, apiKey, opts = {}) {
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${apiKey}`;
      const r = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify({
          contents: [{ parts: [{ text: prompt }]}],
          generationConfig: {
            temperature: opts.temperature ?? 0.4,
            maxOutputTokens: opts.max_tokens ?? 1024
          }
        })
      });

      const data = await r.json();
      if (!r.ok || !data?.candidates?.[0]) {
        console.error('Gemini error:', r.status, data);
        throw new Error(data?.error?.message || 'Gemini API call failed');
      }
      return data.candidates[0].content.parts[0].text;
    }

    // Adapter: Groq API (OpenAI-kompatibelt)
    async function callGroqAPI(prompt, modelId, apiKey, opts = {}) {
      const url = 'https://api.groq.com/openai/v1/chat/completions';
      const r = await fetch(url, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: modelId,
          messages: [
            { role: 'system', content: 'Du er en norsk sjakktrener. Svar kort, presist og pedagogisk.' },
            { role: 'user', content: prompt }
          ],
          temperature: opts.temperature ?? 0.4,
          max_tokens: opts.max_tokens ?? 4096
        })
      });

      const data = await r.json();
      if (!r.ok || !data?.choices?.[0]?.message?.content) {
        console.error('Groq error:', r.status, data);
        throw new Error(data?.error?.message || 'Groq API call failed');
      }
      return data.choices[0].message.content;
    }

    // Database selector handler
    function handleDbChange() {
        selectedOpeningDb = document.querySelector('input[name="openingDb"]:checked').value;
        console.log(`Opening database changed to: ${selectedOpeningDb}`);
        openingTextCache.clear();
        updateDynamicOpeningInfo();
    }

    /********************* AI Model Selector Functions *********************/
    function populateAIModelSelector() {
      const sel = document.getElementById('aiModelSelector');
      if (!sel) return;
      sel.innerHTML = '';
      for (const key in AI_PROVIDERS) {
        const opt = document.createElement('option');
        opt.value = key;
        opt.textContent = AI_PROVIDERS[key].name;
        if (key === currentAIModel) opt.selected = true;
        sel.appendChild(opt);
      }
      sel.addEventListener('change', e => {
        setCurrentAIModel(e.target.value);
        console.log('AI model switched to:', currentAIModel);
      });
    }

    function loadAIKeyInputs() {
      const gIn = document.getElementById('geminiApiKeyInput');
      const qIn = document.getElementById('groqApiKeyInput');
      if (gIn) gIn.value = getGeminiApiKey();
      if (qIn) qIn.value = getGroqApiKey();
    }

    // Kall denne fra modalens "Lagre"-knapp
    function saveAISettingsFromModal() {
      const gIn = document.getElementById('geminiApiKeyInput');
      const qIn = document.getElementById('groqApiKeyInput');
      if (gIn) setGeminiApiKey(gIn.value);
      if (qIn) setGroqApiKey(qIn.value);
      // re-valider aktiv provider etter lagring
      const p = AI_PROVIDERS[currentAIModel];
      if (p && !p.getApiKey()) {
        alert('Husk √• legge inn API-n√∏kkel for valgt modell f√∏r bruk.');
      }
    }

    /********************* Opening Info Panel Update *********************/
    async function updateDynamicOpeningInfo() {
        if (!OPENING_BOOK.enabled || isInPuzzleMode || sanList.length === 0) {
            document.getElementById('openingInfoPanel').style.display = 'none';
            return;
        }

        const panel = document.getElementById('openingInfoPanel');
        panel.style.display = 'block';

        const fen = game.fen();
        const bookData = await queryLichessOpeningBook(fen);

				if (!bookData || !bookData.moves || bookData.moves.length === 0) {
					panel.style.display = 'none';
					return;
				}
				panel.style.display = 'block';

				// Tittel: bruk ECO/navn hvis tilgjengelig, ellers n√∏ytral tittel
				const nameEl = document.getElementById('openingName');
				if (nameEl) {
					if (bookData.opening) {
						const eco = bookData.opening.eco ? `${bookData.opening.eco}: ` : '';
						nameEl.textContent = `${eco}${bookData.opening.name}`;
					} else {
						nameEl.textContent = '√Öpningsstatistikk';
					}
				}
        // 2. Oppdater statistikk-seksjonen
        updateOpeningStatsUI(bookData);

        // 3. Hent og vis AI-beskrivelse
        const aiTextEl = document.getElementById('aiOpeningText');
        const currentFen = game.fen();

        if (openingTextCache.has(currentFen)) {
            // Hent fra cache
            aiTextEl.textContent = openingTextCache.get(currentFen);
        } else {
            // Hent fra AI og lagre i cache
            aiTextEl.innerHTML = `<span class="spinner"></span> Laster AI-forklaring...`;

            const moveSequence = game.history().slice(0, idx);
            const theoryData = await getOpeningTheory(moveSequence);

            const aiDescription = await getAIOpeningMoveExplanation(bookData, theoryData);
            aiTextEl.textContent = aiDescription;

            // Lagre resultatet i cachen
            openingTextCache.set(currentFen, aiDescription);
        }
    }

    function updateOpeningStatsUI(bookData) {
      const container = document.getElementById('openingStatsContainer');
      container.innerHTML = '';

      if (!bookData?.moves?.length) {
        container.innerHTML = '<p style="font-size:12px; color:var(--muted);">Ingen statistikk for denne stillingen.</p>';
        return;
      }

      // DB-velger √∏verst
      const dbSelector = document.createElement('div');
      dbSelector.style.cssText = "margin-bottom: 10px; display: flex; gap: 16px; align-items: center; font-size: 12px;";
      dbSelector.innerHTML = `
        <label style="cursor:pointer;"><input type="radio" name="openingDb" value="lichess" onchange="handleDbChange()" ${selectedOpeningDb === 'lichess' ? 'checked' : ''}> Lichess</label>
        <label style="cursor:pointer;"><input type="radio" name="openingDb" value="masters" onchange="handleDbChange()" ${selectedOpeningDb === 'masters' ? 'checked' : ''}> Masters</label>
      `;
      container.appendChild(dbSelector);

      const totalGames = bookData.moves.reduce((s, m) => s + m.total, 0);
      const currentMoveData = { white: bookData.white, draws: bookData.draws, black: bookData.black };

      const lastMoveSan = game.history()[idx - 1] || 'Start';
      container.appendChild(createStatsLine(lastMoveSan, totalGames, currentMoveData, totalGames, true));

      // Topp 3 neste trekk
      bookData.moves.slice(0, 3).forEach(move => {
        container.appendChild(createStatsLine(move.san, move.total, move, totalGames));
      });
    }

    function createStatsLine(label, games, data, totalGames, isHeader = false) {
        const line = document.createElement('div');
        line.className = 'move-stats-line';

        const percentage = totalGames > 0 ? ((games / totalGames) * 100).toFixed(0) : 0;
        const labelText = isHeader ? `<strong>${label}</strong>` : `<span class="move-san">${label}</span> <span style="color:var(--muted);">${percentage}%</span>`;

        const totalResults = data.white + data.draws + data.black;
        const whitePct = totalResults > 0 ? (data.white / totalResults * 100) : 0;
        const drawPct = totalResults > 0 ? (data.draws / totalResults * 100) : 0;
        const blackPct = 100 - whitePct - drawPct;

        line.innerHTML = `
            <div>${labelText}</div>
            <div class="stats-bar-container">
                <div class="stats-bar-segment stats-bar-white" style="width: ${whitePct}%;" title="Hvit vinner">${whitePct.toFixed(0)}%</div>
                <div class="stats-bar-segment stats-bar-draw" style="width: ${drawPct}%;" title="Remis">${drawPct.toFixed(0)}%</div>
                <div class="stats-bar-segment stats-bar-black" style="width: ${blackPct}%;" title="Svart vinner">${blackPct.toFixed(0)}%</div>
            </div>
        `;
        return line;
    }

    async function getAIOpeningMoveExplanation(bookData, theoryData) {
        try {
            const lastMove = game.history({ verbose: true })[idx - 1]?.san || "Startposisjon";
            const openingName = bookData.opening?.name || "Ukjent √•pning";
            let statsText = '';
            if (bookData.moves && bookData.moves.length > 0) {
                const topMove = bookData.moves[0];
                const totalGames = bookData.moves.reduce((sum, m) => sum + m.total, 0);
                const movePopularity = totalGames > 0 ? (topMove.total / totalGames * 100).toFixed(0) : 'N/A';
                statsText = `Mest popul√¶re svar er ${topMove.san} (spilt i ${movePopularity}% av partiene).`;
            }
            const wikibooksText = theoryData?.translatedExtract || "Ingen spesifikk teori funnet.";
            const dbSourceName = selectedOpeningDb === 'lichess' ? 'Lichess-databasen (alle spillere)' : 'Mester-databasen (tittelspillere)';

            const prompt = `
Rolle: Du er AI-sjakktreneren Sjakkaro for nybegynnere (ca. 900 Elo i spillestyrke).
Oppgave: Forklar det siste trekket i en sjakk√•pning, eller gi en introduksjon til partiet hvis det er startposisjonen. Bruk dataen du f√•r til √• skrive en kort, l√¶rerik beskrivelse (maks 5-7 setninger).
Regler:
1.  Bruk kun norske sjakkbegreper.
2.  V√¶r presis, enkel og motiverende.
3.  Fokuser p√• det som er relevant for en nybegynner.
4.  V√¶r objektiv og tidl√∏s. Unng√• "Lykke til" etc.
5.  PRIORITERING: Baser forklaringen din prim√¶rt p√• trekkets grunnleggende form√•l og statistikken fra den valgte databasen. Bruk Wikibooks-teksten som sekund√¶r kontekst.
6.  HVIS DATA MANGLER: Fokuser p√• generelle strategiske ideer.
Struktur:
-   Trekkets form√•l (hva oppn√•r det?).
-   Planer og ideer (hva er den vanligste planen?).
-   Vanlige fortsettelser (hva er den mest popul√¶re responsen?).
Data:
-   Datakilde i bruk: ${dbSourceName}
-   Siste trekk: ${lastMove}
-   √Öpningens navn: ${openingName}
-   Statistikk: ${statsText}
-   Teoretisk kontekst: ${wikibooksText}
SPESIALINSTRUKSJON:
-   Hvis "Datakilde" er "Mester-databasen", legg vekt p√• hva mesterne foretrekker sammenlignet med generelle trekk.
-   Hvis "Siste trekk" er "Startposisjon", gi en generell introduksjon til √•pningen.
Generer kun den norske beskrivelsesteksten.`;

            return await getAICompletion(prompt);
        } catch (e) {
            console.error('AI opening explanation error:', e);
            return "Kunne ikke laste forklaring for dette trekket.";
        }
    }

    // Konverter SAN moves til UCI format for Opening Book API
    function sanToUciMoves(sanMoves, maxMoves = -1) {
      const chess = new Chess();
      const uciMoves = [];

      const movesToProcess = maxMoves > 0 ? sanMoves.slice(0, maxMoves) : sanMoves;

      for (const san of movesToProcess) {
        const move = chess.move(san);
        if (!move) break;
        uciMoves.push(move.from + move.to + (move.promotion || ''));
      }

      return uciMoves;
    }

    function buildFenFromMoves(moves) {
      const chess = new Chess();
      for (const uci of moves) {
        const from = uci.slice(0, 2);
        const to = uci.slice(2, 4);
        const promotion = uci.slice(4) || undefined;
        chess.move({from, to, promotion});
      }
      return chess.fen();
    }

    // Hybrid evaluering: PGN > Opening Book > Stockfish
    async function getHybridEvaluation(positionIndex, uciMoves, pgnEvals) {
      // 1. Sjekk f√∏rst PGN-evalueringer (raskest og mest p√•litelig)
      if (pgnEvals && pgnEvals[positionIndex]) {
        return {
          source: 'PGN',
          evaluation: pgnEvals[positionIndex],
          opening: null,
          stats: null
        };
      }

      // 2. Pr√∏v √•pningsbok for tidlige trekk
      if (OPENING_BOOK.enabled && positionIndex <= OPENING_BOOK.maxPlies) {
        try {
          const fen = buildFenFromMoves(uciMoves);
          const bookData = await queryLichessOpeningBook(fen);

          if (bookData) {
            console.log('Opening book data found:', bookData);
            const evaluation = calculateOpeningEvaluation(bookData);
            console.log('Calculated evaluation:', evaluation);
            console.log('Opening info from API:', bookData.opening);
            if (evaluation !== null) {
              return {
                source: 'Opening',
                evaluation: evaluation,
                opening: bookData.opening || { name: 'Unknown Opening' },
                eco: bookData.opening?.eco,
                stats: {
                  totalGames: bookData.moves.reduce((sum, m) => sum + m.total, 0),
                  topMoves: bookData.moves.slice(0, 3).map(m => ({
                    san: m.san,
                    total: m.total,
                    performance: (m.performance * 100).toFixed(1)
                  }))
                }
              };
            }
          }
        } catch (error) {
          console.warn('Opening book query failed:', error);
        }
      }

      // 3. Fall tilbake til Stockfish
      const prefs = getEnginePrefs();
      const stockfishResult = await analyzePositionWithMoves(uciMoves, prefs);
      let score = stockfishResult?.score ?? '0.00';

      // Juster perspektiv til Lichess-standard (alltid fra hvits perspektiv)
      if(/^(-?\d+(?:\.\d+)?)$/.test(String(score))) {
        let num = parseFloat(score);
        const isBlackToMove = (positionIndex % 2 === 1);
        if(isBlackToMove) {
          num = -num; // Inverter evalueringen for svarts trekk
        }
        score = num >= 0 ? '+' + num.toFixed(2) : num.toFixed(2);
      }

      return {
        source: 'Stockfish',
        evaluation: score,
        opening: null,
        stats: null
      };
    }

    function updatePlayerInfoPanel(gameData) {
      const panel = document.getElementById('playerInfoPanel');
      if (!gameData) { panel.style.display = 'none'; return; }

      document.getElementById('whitePlayerName').textContent   = gameData.white || 'Hvit';
      document.getElementById('whitePlayerRating').textContent = gameData.whiteElo ? `(${gameData.whiteElo})` : '';
      const wDiff = document.getElementById('whitePlayerRatingDiff');
      if (gameData.whiteRatingDiff != null && gameData.whiteRatingDiff !== '') {
        const d = parseInt(gameData.whiteRatingDiff, 10);
        wDiff.textContent = `(${d >= 0 ? '+' : ''}${d})`;
        wDiff.className = 'player-rating-diff ' + (d >= 0 ? 'positive' : 'negative');
      } else { wDiff.textContent = ''; wDiff.className = 'player-rating-diff'; }

      document.getElementById('blackPlayerName').textContent   = gameData.black || 'Svart';
      document.getElementById('blackPlayerRating').textContent = gameData.blackElo ? `(${gameData.blackElo})` : '';
      const bDiff = document.getElementById('blackPlayerRatingDiff');
      if (gameData.blackRatingDiff != null && gameData.blackRatingDiff !== '') {
        const d = parseInt(gameData.blackRatingDiff, 10);
        bDiff.textContent = `(${d >= 0 ? '+' : ''}${d})`;
        bDiff.className = 'player-rating-diff ' + (d >= 0 ? 'positive' : 'negative');
      } else { bDiff.textContent = ''; bDiff.className = 'player-rating-diff'; }

      panel.style.display = 'block';
    }

    function updateGameMetaInfo(gameData) {
      const metaEl = document.getElementById('gameMetaInfo');
      metaEl.innerHTML = '';
      if (!gameData) return;
      const parts = [];
      if (gameData.timeControl) parts.push(`<span>Tid: ${gameData.timeControl}</span>`);
      if (gameData.result)      parts.push(`<span>Res: ${gameData.result}</span>`);
      metaEl.innerHTML = parts.join('');
    }

    function init(){
      document.querySelectorAll('.tab').forEach(b=>b.addEventListener('click',onTab));
      document.getElementById('btnPrev').addEventListener('click',prevMove);
      document.getElementById('btnNext').addEventListener('click',nextMove);
      document.getElementById('btnStart').addEventListener('click',resetPosition);
      document.getElementById('btnEnd').addEventListener('click',goToEnd);
      document.getElementById('btnDkart').addEventListener('click',toggleDkart);
      document.getElementById('btnAnalyze').addEventListener('click',openLichessAnalysis);
      document.getElementById('btnPGN').addEventListener('click',openPGNModal);
      document.getElementById('closeModal').addEventListener('click',closePGNModal);
      document.getElementById('cancelBtn').addEventListener('click',closePGNModal);
      document.getElementById('configBtn').addEventListener('click',openConfigModal);
      document.getElementById('closeConfigModal').addEventListener('click',closeConfigModal);
      document.getElementById('saveConfigBtn').addEventListener('click',saveConfig);
      document.getElementById('resetConfigBtn').addEventListener('click',resetConfig);
      document.getElementById('fetchLichessBtn').addEventListener('click',fetchLichessGames);
      document.getElementById('loadFileBtn').addEventListener('click',()=>document.getElementById('pgnFile').click());
      document.getElementById('pgnFile').addEventListener('change',handleFileInput);
      document.getElementById('selectGameBtn').addEventListener('click',selectGameFromFile);
      document.getElementById('loadTextBtn').addEventListener('click',loadFromText);

      // Chat event listeners
      document.getElementById('chatSendBtn').addEventListener('click', handleChatMessage);
      document.getElementById('chatInput').addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
              handleChatMessage();
          }
      });

      // Add opening book configuration listeners
      document.getElementById('openingEnabled')?.addEventListener('change', updateOpeningBookConfig);
      document.getElementById('openingStrategy')?.addEventListener('change', updateOpeningBookConfig);
      document.getElementById('minGamesInput')?.addEventListener('input', updateOpeningBookConfig);
      document.getElementById('maxPliesInput')?.addEventListener('input', updateOpeningBookConfig);

      // Les aktiv modell f√∏r vi fyller UI
      currentAIModel = localStorage.getItem('aiModel') ?? 'gemini-2.5-flash-lite';

      // Migrer gamle modell-n√∏kler til nye ID-baserte n√∏kler
      if (currentAIModel === 'gemini-flash-lite') {
        setCurrentAIModel('gemini-2.5-flash-lite');
        currentAIModel = 'gemini-2.5-flash-lite';
        console.log('Migrated from old Gemini key to model-ID based key');
      }
      if (currentAIModel === 'groq-llama3-8b' || currentAIModel === 'groq-deepseek-r1') {
        setCurrentAIModel('deepseek-r1-distill-llama-70b');
        currentAIModel = 'deepseek-r1-distill-llama-70b';
        console.log('Migrated from old Groq key to model-ID based key');
      }

      // Migrer gammel hardkodet n√∏kkel til localStorage (hvis den ikke allerede finnes)
      if (!getGeminiApiKey() && typeof GEMINI_API_KEY !== 'undefined' && GEMINI_API_KEY) {
        setGeminiApiKey('AIzaSyBhT--1GglCIdvAN_zq7NzFuwcd9bWFfrA');
      }

      // Fyll AI UI
      populateAIModelSelector();
      loadAIKeyInputs();

      const panelToggle=document.getElementById('panelToggle');
      const sidepanel=document.getElementById('sidepanel');
      const overlay=document.getElementById('overlay');
      panelToggle.addEventListener('click',()=>{sidepanel.classList.toggle('open');overlay.classList.toggle('show');panelToggle.setAttribute('aria-expanded',sidepanel.classList.contains('open'))});
      overlay.addEventListener('click',()=>{sidepanel.classList.remove('open');overlay.classList.remove('show');panelToggle.setAttribute('aria-expanded','false')});

      window.addEventListener('keydown',(e)=>{
        if(!e.key) return;
        if(e.key==='ArrowRight'){ nextMove(); }
        else if(e.key==='ArrowLeft'){ prevMove(); }
        else if(e.key==='ArrowUp'){ e.preventDefault(); /* autoplay fjernet */ }
        else if(e.key==='ArrowDown'){ resetPosition(); }
        else if(e.key==='CapsLock'){ toggleDkart(); }
      });

      const cfg={
        position:'start',
        draggable:true,
        showNotation:true,
        pieceTheme:'https://cdn.jsdelivr.net/gh/lichess-org/lila@master/public/piece/alpha/{piece}.svg',
        onDrop: handlePieceDrop
      };
      if(window.Chessboard){board=Chessboard('board',cfg);} else if(window.ChessBoard){board=ChessBoard('board',cfg);} else if(window.jQuery&&$.fn&&$.fn.chessboard){board=$('#board').chessboard(cfg);} else {throw new Error('Chessboard library not found.');}

      loadCategory('opening');
      tryStartEngine();
      window.addEventListener('resize',()=>{board.resize(); if(dkOn) drawDkart();});

      // Load puzzle data on startup
      loadPuzzleData();
    }

    /********************* Modal utils *********************/
    function openPGNModal(){document.getElementById('pgnModal').classList.add('show');clearInputs();clearMessages();}
    function closePGNModal(){document.getElementById('pgnModal').classList.remove('show');clearMessages();clearInputs();}

    function openConfigModal(){
      populateAIModelSelector();
      loadAIKeyInputs();
      document.getElementById('configModal').classList.add('show');
    }
    function closeConfigModal(){document.getElementById('configModal').classList.remove('show');}

    function saveConfig(){
      updateOpeningBookConfig();
      saveAISettingsFromModal();
      closeConfigModal();
      console.log('Configuration saved');
    }

    function resetConfig(){
      // Reset to default values
      document.querySelector('input[name="mode"][value="movetime"]').checked = true;
      document.getElementById('mtInput').value = 1500;
      document.getElementById('depthInput').value = 18;
      document.getElementById('mpvInput').value = 3;
      document.getElementById('openingEnabled').checked = true;
      document.getElementById('openingStrategy').value = 'balanced';
      document.getElementById('minGamesInput').value = 100;
      document.getElementById('maxPliesInput').value = 20;

      // Reset AI settings
      setCurrentAIModel('gemini-2.5-flash-lite');
      document.getElementById('geminiApiKeyInput').value = '';
      document.getElementById('groqApiKeyInput').value = '';
      populateAIModelSelector();

      updateOpeningBookConfig();
      console.log('Configuration reset to defaults');
    }
    function clearMessages(){document.getElementById('errorMessage').style.display='none';document.getElementById('loadingMessage').style.display='none'}
    function showError(msg){const el=document.getElementById('errorMessage');el.textContent=msg;el.style.display='block';document.getElementById('loadingMessage').style.display='none'}
    function showLoading(msg){const el=document.getElementById('loadingMessage');el.innerHTML=`<span class="spinner"></span>${msg}`;el.style.display='block';document.getElementById('errorMessage').style.display='none'}
    function hideMessages(){clearMessages()}
    function clearInputs(){document.getElementById('lichessUsername').value='';document.getElementById('pgnText').value='';const fi=document.getElementById('pgnFile');if(fi) fi.value='';const sect=document.getElementById('gameSelectSection');if(sect) sect.style.display='none';const sel=document.getElementById('gameSelect');if(sel) sel.innerHTML='';fileGameList=[]}

    async function fetchLichessGames(){
      const username=document.getElementById('lichessUsername').value.trim().replace('@','');
      const numGames=parseInt(document.getElementById('numGames').value)||1;
      if(!username){showError('Vennligst skriv inn et Lichess‚Äëbrukernavn.');return}
      showLoading('Henter partier fra Lichess...');
      try{
        // 1) pr√∏v lokal server hvis du kj√∏rer en proxy/back‚Äëend
        const resp = await fetch(`${SERVER_URL}/fetch_lichess_games`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({username, max_games:numGames})});
        if(resp.ok){const data=await resp.json(); if(data.games?.length){await loadGameData(data.games[0]); closePGNModal(); return;} else {showError('Ingen partier funnet.'); return;}}
        // hvis ikke ok, faller vi til direkte‚Äëhent
        throw new Error('Local server not available');
      }catch(_){
        // 2) Direktehenting fra Lichess API (PGN som tekst). CORS er tillatt av Lichess.
        try{
          // NB: application/x-chess-pgn returnerer flere partier i rekkef√∏lge
          const url=`https://lichess.org/api/games/user/${encodeURIComponent(username)}?max=${numGames}&moves=true`;
          const r = await fetch(url,{headers:{'Accept':'application/x-chess-pgn'}});
          if(!r.ok){throw new Error(`Lichess svarte ${r.status}`)}
          const text = await r.text();
          // splitt p√• [Event]
          const chunks = text.replace(/\r\n/g,'\n').trim().split(/\n\n(?=\[Event)/g).filter(s=>s.trim().length>0);
          if(!chunks.length){throw new Error('Fant ingen partier i svaret')}
          await loadGameFromPGN(chunks[0]);
          closePGNModal();
        }catch(e){console.error('Lichess fetch error:', e); showError('Kunne ikke hente partier fra Lichess (ingen lokal server, og direktekall feilet).');}
      }
    }

    async function loadFromText(){
      const pgnText=document.getElementById('pgnText').value.trim();
      if(!pgnText){showError('PGN-data kan ikke v√¶re tom.');return}
      showLoading('Behandler PGN...');
      try{await loadGameFromPGN(pgnText);closePGNModal();}catch(e){console.error('Text load error:',e);showError('Kunne ikke tolke PGN-data. Sjekk format.');}
    }

    async function handleFileInput(ev){
      const file=ev.target.files&&ev.target.files[0];
      if(!file){showError('Vennligst velg en PGN‚Äëfil.');return}
      showLoading('Laster fil...');
      try{
        const text=await file.text();
        if(!text || typeof text !== 'string'){
          throw new Error('Invalid file content');
        }
        const normalized=text.replace(/\r\n/g,'\n');
        const chunks=normalized.trim().split(/\n\n(?=\[Event)/g).filter(x=>x.trim().length>0);
        if(chunks.length<=1){
          await loadGameFromPGN(chunks[0]||normalized);
          closePGNModal();
        }
        else{
          fileGameList=chunks;
          const select=document.getElementById('gameSelect');
          select.innerHTML='';
          chunks.forEach((pgn,i)=>{
            let label=`Parti ${i+1}`;
            try{
              const header={};
              const re=/\[(\w+)\s+"([^"]*)"\]/g;
              let m;
              while((m=re.exec(pgn))) header[m[1]]=m[2];
              const w=header.White||'Ukjent';
              const b=header.Black||'Ukjent';
              const d=header.Date||'';
              label=`${i+1}: ${w} vs ${b}${d?` (${d})`:''}`;
            }catch(e){console.error('Header parsing error:',e);}
            const opt=document.createElement('option');
            opt.value=String(i);
            opt.textContent=label;
            select.appendChild(opt);
          });
          document.getElementById('gameSelectSection').style.display='block';
          hideMessages();
        }
      }catch(e){
        console.error('File load error:',e);
        showError('Kunne ikke laste PGN‚Äëfil.');
      }
    }

    async function selectGameFromFile(){
      try{const sel=document.getElementById('gameSelect');const k=parseInt(sel.value,10);if(isNaN(k)||!fileGameList[k]){showError('Ugyldig partisvalg.');return}
        await loadGameFromPGN(fileGameList[k]); fileGameList=[]; document.getElementById('gameSelect').innerHTML=''; document.getElementById('gameSelectSection').style.display='none'; closePGNModal();
      }catch(e){console.error('Select game error:',e);showError('Kunne ikke laste valgt parti.');}
    }

    async function loadGameFromPGN(pgnText){
      if(!pgnText || typeof pgnText !== 'string'){
        throw new Error('Invalid PGN text');
      }
      const normalized=pgnText.replace(/\r\n/g,'\n');
      const chunks=normalized.trim().split(/\n\n(?=\[Event)/g);
      const pgn=(chunks[0]||normalized).trim();
      const chess=new Chess();
      if(!chess.load_pgn(pgn,{sloppy:true})) throw new Error('Ugyldig PGN');
      const header=chess.header();
      const gameData={
        id:header.Site?.split('/').pop()||`manual-${Date.now()}`,
        pgn
      };
      await loadGameData(gameData);
    }

    async function loadGameData(gameData){
      selectedOpeningDb = 'lichess';
      // Legg til disse linjene for √• tilbakestille chatten
      document.getElementById('chatHistory').innerHTML = '';
      document.getElementById('chatPanel').style.display = 'none';
      chatHistory = [];

      openingTextCache.clear();
      loadedGame = gameData;

      game = new Chess();
      game.load_pgn(gameData.pgn,{sloppy:true});
      const header = game.header();

      // Utvid hodeinfo
      loadedGame.white = header.White || 'Ukjent';
      loadedGame.black = header.Black || 'Ukjent';
      loadedGame.result = header.Result || '*';
      loadedGame.whiteElo = header.WhiteElo;
      loadedGame.blackElo = header.BlackElo;
      loadedGame.whiteRatingDiff = header.WhiteRatingDiff;
      loadedGame.blackRatingDiff = header.BlackRatingDiff;
      loadedGame.timeControl = header.TimeControl;

      const history=game.history();
      game.reset();
      sanList=history; idx=0;
      board.position('start');

      // Tittel skal v√¶re statisk ‚Äì navn vises i spillerpanelet
      document.getElementById('boardTitle').textContent = 'Partianalyse';
      updatePlayerInfoPanel(loadedGame);
      updateGameMetaInfo(loadedGame);

      renderMoveList();
      updateButtons();

      // Parse opening info from PGN headers (works for all game loading paths)
      gameOpeningInfo = null;
      if (gameData.pgn) {
        console.log('üîç Parsing opening from PGN headers...');
        const ecoMatch = gameData.pgn.match(/\[ECO\s+"([^"]*)"\]/);
        const openingMatch = gameData.pgn.match(/\[Opening\s+"([^"]*)"\]/);
        console.log('ECO match:', ecoMatch);
        console.log('Opening match:', openingMatch);
        if (ecoMatch && openingMatch) {
          gameOpeningInfo = {
            name: openingMatch[1],
            eco: ecoMatch[1],
            totalGames: 0,
            source: 'PGN'
          };
          console.log('‚úÖ Opening info from PGN headers:', gameOpeningInfo);
        } else {
          console.log('‚ùå No opening info found in PGN headers');
        }
      }

      // Sjekk om PGN allerede inneholder evalueringer
      if (hasEvaluations(gameData.pgn)) {
        console.log('PGN contains evaluations - using existing evals instead of Stockfish');
        showLoading('Bruker eksisterende evalueringer fra PGN...');

        try {
          // Ekstraher evalueringer fra PGN
          const extractedEvals = extractEvaluationsFromPGN(gameData.pgn);
          evaluations = alignEvaluationsWithMoves(extractedEvals, sanList.length);

          // Initialize enhancedEvals for PGN path
          enhancedEvals = evaluations.map(eval => ({
            source: 'PGN',
            evaluation: eval,
            opening: null,
            stats: null
          }));
          console.log('Initialized enhancedEvals for PGN path:', enhancedEvals.length);

          // Oppdater UI og g√• direkte til AI-analyse
          renderMoveList();
          hideMessages();

          // Vis evalueringskilde i UI
          showEvaluationSource('PGN');

          console.log('Using PGN evaluations:', evaluations);
          await analyzeGame();

          // Update opening information panel after loading game with PGN evaluations
          console.log('üéØ After PGN eval loading - calling updateDynamicOpeningInfo');
          updateDynamicOpeningInfo();
        } catch (error) {
          console.error('Error processing PGN evaluations:', error);
          showError('Feil ved behandling av PGN-evalueringer. Faller tilbake til Stockfish...');
          // Fallback til normal Stockfish-evaluering
          await evaluateGamePositions();
        }
      } else {
        console.log('PGN has no evaluations - running Stockfish analysis');
        // Normal arbeidsflyt med Stockfish
        await evaluateGamePositions();
      }
    }

    /********************* Stockfish *********************/
    function tryStartEngine(){
      try{
        console.log('Starting Stockfish engine...');
        engine=new Worker('stockfish.js');
        engine.onmessage=(e)=>handleEngineMsg(String(e.data));
        engine.onerror=(e)=>{console.error('Stockfish worker error:', e);};
        engine.postMessage('uci');
        console.log('UCI command sent');
      }
      catch(e){
        console.error('Fant ikke stockfish.js i mappen.',e);
        alert('Legg stockfish.js (WASM build) i samme mappe som index.html.');
      }
    }

    function handleEngineMsg(msg){
      console.log('Stockfish:', msg); // Debug log

      if(msg==="uciok"){ // sett opsjoner n√•r UCI er etablert
        console.log('Setting engine options...');
        const { mpv } = getEnginePrefs();

        // Kun sett opsjoner som denne motoren st√∏tter
        engine.postMessage(`setoption name MultiPV value ${mpv}`);

        // Sjekk at Hash ikke er l√•st til 16 (som i console output)
        if(engineCaps.options.Hash && engineCaps.options.Hash.max > 16) {
          engine.postMessage('setoption name Hash value 64');
        }

        if(engineCaps.threads && engineCaps.options.Threads && engineCaps.options.Threads.max > 1){
          engine.postMessage('setoption name Threads value '+Math.min(2, engineCaps.options.Threads.max));
        }

        console.log('Sending isready...');
        engine.postMessage('isready');
        return;
      }
      if(msg.startsWith('option name ')){
        // parse opsjoner for √• oppdage Threads mv.
        // eksempel: option name Threads type spin default 1 min 1 max 1024
        const m = msg.match(/^option name (\S+) type (\S+)(.*)$/);
        if(m){
          const name=m[1]; const type=m[2]; const rest=m[3]||''; const opt={type};
          const d=rest.match(/default\s+([\S]+)/); if(d) opt.default=d[1];
          const min=rest.match(/min\s+(\d+)/); const max=rest.match(/max\s+(\d+)/);
          if(min) opt.min=parseInt(min[1],10); if(max) opt.max=parseInt(max[1],10);
          engineCaps.options[name]=opt; if(name==='Threads') engineCaps.threads=true;
        }
        return;
      }
      if(msg==='readyok'){ console.log('‚úÖ Stockfish klar'); return; }
      if(msg.startsWith('info')){
        const mMate=msg.match(/score mate (-?\d+)/); const mCp=msg.match(/score cp (-?\d+)/); const mD=msg.match(/ depth (\d+)/); const pvM=msg.match(/ pv (.+)/);
        if(mMate){
          const n=parseInt(mMate[1],10);
          // Konverter til Lichess-format (#X for mate)
          lastInfo.score = n>=0 ? `#${n}` : `#${Math.abs(n)}`;
        }
        if(mCp){
          let score = parseInt(mCp[1],10) / 100;
          // Ingen perspektiv-justering her - det gj√∏res i evaluateGamePositions basert p√• posisjon-indeks
          lastInfo.score = score.toFixed(2);
        }
        if(mD){ lastInfo.depth=parseInt(mD[1],10); }
        if(pvM){ lastInfo.pv=pvM[1]; }
        return;
      }
      if(msg.startsWith('bestmove')){
        console.log('Bestmove received:', msg); // Debug log
        if(analysisResolver){
          const r=analysisResolver;
          analysisResolver=null;
          r(lastInfo);
        }
        return;
      }
    }

    function uciPositionFromMoves(moves){ return `position startpos${moves?.length?(' moves '+moves.join(' ')):' '}`; }

    function analyzePositionWithMoves(moves, prefs){
      return new Promise((resolve, reject)=>{
        lastInfo={score:null,depth:null,pv:null};
        let settled=false;

        const cleanup=()=>{ analysisResolver=null; };

        const hardTimeout=setTimeout(()=>{
          if(!settled){
            settled=true;
            console.log('Analysis timeout - stopping engine');
            try{engine.postMessage('stop')}catch(e){console.log('Stop error:', e)}
            cleanup();
            reject(new Error('Analysis timeout'));
          }
        }, 10000); // 10 seconds

        analysisResolver=(final)=>{
          if(settled) return;
          settled=true;
          clearTimeout(hardTimeout);
          cleanup();
          console.log('Analysis completed:', final);
          resolve(final);
        };

        try{
          console.log('Starting analysis for moves:', moves);

          // Simplified command sequence
          engine.postMessage('stop');

          setTimeout(() => {
            if(settled) return;

            const posCmd = uciPositionFromMoves(moves);
            console.log('Sending position:', posCmd);
            engine.postMessage(posCmd);

            // Bruk alltid movetime for bedre kompatibilitet
            const moveTime = prefs.mode === 'movetime' ? prefs.ms : 1000;
            const goCmd = `go movetime ${moveTime}`;
            console.log('Sending go command:', goCmd);
            engine.postMessage(goCmd);
          }, 100);
        }catch(err){
          if(!settled) {
            settled=true;
            clearTimeout(hardTimeout);
            cleanup();
            reject(err);
          }
        }
      });
    }

    async function evaluateGamePositions(){
      if(!loadedGame || sanList.length===0) return;
      if(!engine) tryStartEngine();

      // Vent litt p√• at engine skal bli klar
      console.log('Waiting for engine to be ready...');
      await new Promise(resolve => setTimeout(resolve, 2000));

      updateOpeningBookConfig(); // Oppdater konfigurasjon f√∏r evaluering
      showLoading('Evaluerer stillinger med hybrid-tiln√¶rming...');

      // bygg alle posisjoner som UCI‚Äëtrekksekvenser
      const temp=new Chess(); const positions=[[]]; // startpos
      for(const m of sanList){
        const mo=temp.move(m);
        if(!mo){console.warn('Ugyldig trekk i history',m); break;}
        positions.push([...(positions[positions.length-1]), mo.from+mo.to+(mo.promotion||'')]);
      }

      evaluations=[];
      enhancedEvals=[];
      let sourceStats = { PGN: 0, Opening: 0, Stockfish: 0 };

      // gameOpeningInfo should already be set from loadGameData()
      console.log('üîç Starting evaluateGamePositions with gameOpeningInfo:', gameOpeningInfo);

      for(let i=0;i<positions.length;i++){
        try{
          const result = await getHybridEvaluation(i, positions[i], null);

          evaluations.push(result.evaluation);
          enhancedEvals.push(result);
          sourceStats[result.source]++;

          // Update opening info with Lichess data when available
          if (result.source === 'Opening' && result.opening && result.opening.name) {
            gameOpeningInfo = {
              name: result.opening.name,
              eco: result.opening.eco || result.eco || gameOpeningInfo?.eco,
              totalGames: result.stats?.totalGames || 0,
              source: 'Lichess'
            };
            console.log('gameOpeningInfo updated with Lichess data:', gameOpeningInfo);
          }

          const phase = result.source === 'Opening' ? '√Öpningsbok' :
                       result.source === 'PGN' ? 'PGN-data' : 'Stockfish';
          console.log(`Position ${i}: ${result.evaluation} (${phase})`);

        }catch(e){
          console.warn('Pos',i,'feilet:',e.message);
          const fb=evaluations.length? evaluations[evaluations.length-1] : '0.00';
          evaluations.push(fb);
          enhancedEvals.push({source: 'Error', evaluation: fb, opening: null, stats: null});
        }
        const p=Math.round((i+1)/positions.length*100);
        showLoading(`Evaluerer stillinger (hybrid)... ${p}%`);
      }

      // Vis evalueringskilde basert p√• hvilken som ble brukt mest
      const primarySource = Object.keys(sourceStats).reduce((a, b) => sourceStats[a] > sourceStats[b] ? a : b);
      if (sourceStats.Opening > 0 && sourceStats.Stockfish > 0) {
        showEvaluationSource('Hybrid');
      } else {
        showEvaluationSource(primarySource);
      }

      console.log('Evaluation sources used:', sourceStats);
      if (gameOpeningInfo) {
        console.log('Opening detected:', gameOpeningInfo);
      }

      renderMoveList();
      hideMessages();
      await analyzeGame();

      // Update opening information panel
      console.log('üéØ About to call updateDynamicOpeningInfo');
      updateDynamicOpeningInfo();
    }

    /********************* AI‚Äëanalyse + autoscroll‚Äëfix *********************/
    function mdToHtml(md){
      // Minimal konvertering for overskrifter og fet tekst slik at autoscroll kan finne <h3>
      let html=md.replace(/^###\s+(.+)$/gm,'<h3>$1</h3>');
      html=html.replace(/^##\s+(.+)$/gm,'<h2>$1</h2>');
      html=html.replace(/^#\s+(.+)$/gm,'<h1>$1</h1>');
      html=html.replace(/\*\*(.*?)\*\*/g,'<strong>$1</strong>');
      html=html.replace(/\n\n/g,'\n'); // litt kompakt
      html=html.replace(/\n/g,'<br/>');
      return html;
    }

    async function analyzeGame(){
      if(!loadedGame) return; showLoading('Analyserer parti med AI...');
      try{
        // inkluder evals i prompt med trekk-detaljer og √•pningskontext
        let evalSummary='';
        let moveDetails='';
        let openingContext='';

        // √Öpningsinformasjon
        if(gameOpeningInfo) {
          openingContext = `\n\n√ÖPNINGSINFORMASJON:\n`;
          openingContext += `- √Öpning: ${gameOpeningInfo.eco ? gameOpeningInfo.eco + ' - ' : ''}${gameOpeningInfo.name}\n`;
          openingContext += `- Basert p√• ${gameOpeningInfo.totalGames.toLocaleString()} Lichess-partier\n`;

          // Finn √•pningsbok-evalueringer og legg til kontext
          const openingEvals = enhancedEvals.filter(e => e && e.source === 'Opening').slice(0, 5);
          if(openingEvals.length > 0) {
            openingContext += `- Teoretisk vurdering av de f√∏rste ${openingEvals.length} trekkene\n`;
            openingContext += `- Sammenlign spillerens valg med mesterspill-statistikk\n`;
          }
        }

        if(evaluations.length){
          evalSummary='\n\nEVALUERINGER for hver posisjon (0=start):\n';
          moveDetails='\n\nTrekK-DETALJER for referanse:\n';

          for(let i=0;i<Math.min(evaluations.length,sanList.length+1);i++){
            const mv=i===0?'start':sanList[i-1]||'?';
            const source = enhancedEvals[i] ? enhancedEvals[i].source : 'Unknown';
            const sourceLabel = source === 'Opening' ? '(√Öpningsbok)' :
                               source === 'PGN' ? '(PGN)' :
                               source === 'Stockfish' ? '(Stockfish)' : '';

            evalSummary+=`#${i} ${mv}: ${evaluations[i]||'0.00'} ${sourceLabel}\n`;

            if(i>0){
              const moveNum = Math.ceil(i / 2);
              const color = (i % 2 === 1) ? 'Hvit' : 'Svart';
              moveDetails+=`Trekk ${moveNum}. ${color}: ${mv}\n`;
            }
          }
        }
        // Forbered listen med gyldige temaer for prompten
        const validThemes = ["fork", "pin", "skewer", "discoveredAttack", "backRankMate", "attraction", "deflection", "mateIn2", "advantage", "crushing", "endgame"];
        const validThemesString = validThemes.join(', ');

        const prompt = `ROLLE OG M√ÖL
Du er en AI-sjakktrener ved navn Sjakkaro. Din personlighet er ekspert, pedagogisk og oppmuntrende. Du snakker til en elev p√• ungdomsskolen som er nybegynner i sjakk.
Ditt m√•l er ikke bare √• p√•peke feil, men √• bygge elevens forst√•else, intuisjon og gode vaner. Analysen skal v√¶re en positiv l√¶ringsopplevelse som motiverer til √• spille mer.

KRITERIER FOR √Ö VELGE N√òKKEL√òYEBLIKK
Du skal identifisere 3-4 av de mest l√¶rerike √∏yeblikkene i partiet. Ikke bare se p√• de st√∏rste svingningene i evalueringen. Bruk f√∏lgende prioriterte kriterier:
1.    Den Uutnyttede Sjansen (H√∏yest prioritet): Finn et trekk der motstanderen gjorde en klar feil, men eleven ikke fant det beste svaret. Forklar hva eleven overs√• og hvorfor det var en viktig mulighet.
2.    Den Store Feilen (Bukk): Identifiser en alvorlig feil eleven gjorde. Fokuser p√• tankeprosessen: Hvorfor var dette en feil, og hvordan kunne den v√¶rt unng√•tt ved √• sjekke for sjakker, slag og trusler?
3.    Brudd p√• et Prinsipp: Finn et trekk som bryter med et viktig, grunnleggende sjakkprinsipp (f.eks. √• flytte dronningen for tidlig, un√∏dvendige bondetrekk foran egen konge, d√•rlig utvikling). Bruk dette til √• forklare hvorfor prinsippet er viktig.
4.    Positiv Forsterkning (Balanser analysen): For √• unng√• en negativ tone, pr√∏v √• inkludere minst ett positivt √∏yeblikk. Dette kan v√¶re et trekk der eleven spilte spesielt bra, fulgte en god plan, eller fant en smart taktisk id√©.

STRUKTUR FOR ANALYSEN (MARKDOWN)
1. Innledning
Start med en kort, positiv og overordnet kommentar om partiet. Nevn for eksempel noe begge spillere gjorde bra.${gameOpeningInfo ? ` Inkluder √•pningsnavn og teoretisk kontekst.` : ``}

2. N√∏kkel√∏yeblikk
Presenter de 3-4 √∏yeblikkene du valgte basert p√• kriteriene over. Bruk dette formatet for hvert:
‚Ä¢    Overskrift: \`### N√∏kkel√∏yeblikk X (Trekk Y. MOVE): En L√¶rerik Tittel\`
‚Ä¢    Hva skjedde: Beskriv trekket og den umiddelbare situasjonen.
‚Ä¢    Vurdering: Forklar hvorfor dette √∏yeblikket er viktig. Knytt det til ett av kriteriene (f.eks. "Her hadde du en gyllen mulighet..." eller "Dette trekket bryter med prinsippet om...").
‚Ä¢    Bedre alternativer: Vis det beste trekket og forklar kort hvorfor det er bedre.

3. Anbefalte √òvelser (Puzzles)
Hvis et n√∏kkel√∏yeblikk egner seg spesielt godt for praktisk √∏ving, kan du foresl√• en oppgave.
‚Ä¢    Skriv en kort, informativ setning som leder inn til √∏velsen.
‚Ä¢    VIKTIG: Rett etter setningen, p√• en ny linje, legg til en maskinlesbar tag: \`[PUZZLE_THEME: tema_navn]\`. Velg det mest relevante 'tema_navn' fra denne listen: ${validThemesString}.

4. Oppsummering og Treningstips
Oppsummer de 2-3 viktigste l√¶ringspunktene fra dette spesifikke partiet. Gi konkrete treningstips som er direkte knyttet til feilene eller de uutnyttede sjansene du identifiserte i n√∏kkel√∏yeblikkene.

INPUT-DATA TILGJENGELIG FOR DEG
Du har tilgang til f√∏lgende data for √• gj√∏re analysen din:
‚Ä¢    PGN: Hele partiet.
‚Ä¢    √Öpningsinformasjon: ${gameOpeningInfo ? `Partiet startet med ${gameOpeningInfo.name}.` : ''}
‚Ä¢    Evalueringsliste: En liste med evalueringer for hver stilling. Store svingninger indikerer ofte, men ikke alltid, et n√∏kkel√∏yeblikk. Bruk denne som en guide, ikke en fasit.
‚Ä¢    Trekkliste: En nummerert liste over alle trekk.

VIKTIGE REGLER
‚Ä¢    Spr√•k: BRUK KUN NORSKE SJAKKBEGREPER fra den vedlagte ordboken.
‚Ä¢    Tone: V√¶r alltid motiverende, selv n√•r du p√•peker feil.

${gameOpeningInfo ? `SPESIELL INSTRUKSJON: Dette partiet spiller ${gameOpeningInfo.name}. Kommenter p√• avvik fra √•pningsteori og sammenlign med statistikk fra ${gameOpeningInfo.totalGames.toLocaleString()} partier. Evalueringer merket "(√Öpningsbok)" er basert p√• mesterspill-data.\n\n` : ``}PGN:\n${loadedGame.pgn}\n${openingContext}${evalSummary}${moveDetails}`;
        let md = await getAICompletion(prompt) || 'Ingen analyse.';

        // Search for [PUZZLE_THEME: ...] tags and replace with buttons
        md = md.replace(/\[PUZZLE_THEME:\s*(\w+)\]/g, (match, theme) => {
          console.log('Found puzzle theme:', theme);
          return `<button class="btn btn--primary" onclick="startPuzzleSequence('${theme}')">üß© Start √∏velse</button>`;
        });

        const html=mdToHtml(md);
        const box=document.getElementById('explainBox'); box.innerHTML = `<h3>AI‚Äëanalyse</h3><div class="ai" style="line-height:1.6;">${html}</div>`;
        hideMessages();
        document.getElementById('chatPanel').style.display = 'block';

        // Update opening information panel after AI analysis is complete
        console.log('üéØ After AI analysis - calling updateDynamicOpeningInfo');
        updateDynamicOpeningInfo();
      }catch(e){ console.error('Analysis error:',e); showError('Kunne ikke analysere partiet med AI. Sett gyldig API‚Äën√∏kkel.'); }
    }

    /********************* PUZZLE SYSTEM *********************/

    // Load puzzle data from CSV file
    async function loadPuzzleData() {
      try {
        console.log('Loading puzzle data from CSV...');
        const response = await fetch('assets/lichess_puzzles_1200.csv');
        if (!response.ok) throw new Error('Failed to load puzzle CSV');

        const csvText = await response.text();
        const lines = csvText.split('\n');
        const headers = lines[0].split(',');

        allPuzzles = [];
        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;

          const values = line.split(',');
          if (values.length >= headers.length) {
            const puzzle = {};
            headers.forEach((header, index) => {
              puzzle[header] = values[index];
            });

            // Only include puzzles in rating range 800-1400
            const rating = parseInt(puzzle.Rating);
            if (rating >= 800 && rating <= 1400) {
              allPuzzles.push(puzzle);
            }
          }
        }

        console.log(`Loaded ${allPuzzles.length} puzzles in rating range 800-1400`);
        return true;
      } catch (error) {
        console.error('Error loading puzzle data:', error);
        return false;
      }
    }

    // Start puzzle sequence based on theme
    function startPuzzleSequence(theme) {
      console.log('Starting puzzle sequence for theme:', theme);

      if (allPuzzles.length === 0) {
        showError('Oppgavedata ikke lastet. Pr√∏v √• laste siden p√• nytt.');
        return;
      }

      // Find suitable puzzle for the theme
      const suitablePuzzles = allPuzzles.filter(puzzle => {
        return puzzle.Themes && puzzle.Themes.includes(theme);
      });

      if (suitablePuzzles.length === 0) {
        showError(`Ingen oppgaver funnet for tema: ${theme}`);
        return;
      }

      // Select random puzzle from suitable ones
      const randomIndex = Math.floor(Math.random() * suitablePuzzles.length);
      const selectedPuzzle = suitablePuzzles[randomIndex];

      launchPuzzle(selectedPuzzle);
    }

    // Launch a specific puzzle
    function launchPuzzle(puzzle) {
      console.log('Launching puzzle:', puzzle.PuzzleId);

      // Save current analysis state
      savedAnalysisFEN = game.fen();

      // Set puzzle mode
      isInPuzzleMode = true;
      currentPuzzle = puzzle;
      currentPuzzleStep = 0;

      // Prepare solution moves
      puzzleSolutionMoves = puzzle.Moves.split(' ');
      console.log('Puzzle solution moves:', puzzleSolutionMoves);

      // Load puzzle position
      game.load(puzzle.FEN);
      board.position(puzzle.FEN);

      // Update board title
      document.getElementById('boardTitle').textContent = `Oppgave ${puzzle.PuzzleId} (Rating: ${puzzle.Rating})`;

      // Auto-play first move (scenario setup) after 500ms
      setTimeout(() => {
        if (puzzleSolutionMoves.length > 0) {
          const firstMove = puzzleSolutionMoves[0];

          // Execute the first move
          const move = game.move({
            from: firstMove.substring(0, 2),
            to: firstMove.substring(2, 4),
            promotion: firstMove.length > 4 ? firstMove[4] : undefined
          });

          if (move) {
            board.position(game.fen());

            // Bestem spillerens farge og roter brettet om n√∏dvendig
            const playerColor = game.turn() === 'w' ? 'white' : 'black';
            board.orientation(playerColor);

            // Highlight the move with yellow color for 2 seconds
            highlightMove(firstMove.substring(0, 2), firstMove.substring(2, 4), 'yellow', 2000);

            const playerColorName = playerColor === 'white' ? 'hvit' : 'svart';
            const instruction = translateThemeToInstruction(puzzle.Themes);
            document.getElementById('boardTitle').textContent = `Du spiller ${playerColorName}, kan du ${instruction}?`;
          }
        }
      }, 500);
    }

    // Highlight a move on the board
    function highlightMove(from, to, color = 'yellow', duration = 2000) {
      // Remove any existing highlights
      $('.square-55d63').removeClass('highlight-yellow highlight-green highlight-red');

      // Add highlight
      $(`.square-${from}`).addClass(`highlight-${color}`);
      $(`.square-${to}`).addClass(`highlight-${color}`);

      // Remove highlight after duration
      setTimeout(() => {
        $(`.square-${from}`).removeClass(`highlight-${color}`);
        $(`.square-${to}`).removeClass(`highlight-${color}`);
      }, duration);
    }

    // Complete puzzle successfully
    function completePuzzle() {
      document.getElementById('boardTitle').textContent = "Oppgave l√∏st! Bra jobbet!";

      // Wait 2-3 seconds then exit puzzle mode
      setTimeout(() => {
        exitPuzzleMode();
      }, 2500);
    }

    // NY HJELPEFUNKSJON FOR PUZZLE-INSTRUKSJONER
    function translateThemeToInstruction(themes) {
        if (themes.includes('mateIn1')) return "finn sjakkmatt i ett trekk";
        if (themes.includes('mateIn2')) return "finn sjakkmatt i to trekk";
        if (themes.includes('mateIn3')) return "finn sjakkmatt i tre trekk";
        if (themes.includes('crushing')) return "skaff deg en knusende fordel";
        if (themes.includes('advantage')) return "skaff deg en avgj√∏rende fordel";
        if (themes.includes('fork')) return "finn en gaffel";
        if (themes.includes('pin')) return "utnytt en binding";
        return "finn det beste trekket"; // Fallback
    }

    // Exit puzzle mode and return to analysis
    function exitPuzzleMode() {
      isInPuzzleMode = false;
      currentPuzzle = null;
      puzzleSolutionMoves = [];
      currentPuzzleStep = 0;

      // Restore analysis position
      if (savedAnalysisFEN) {
        game.load(savedAnalysisFEN);
        board.position(savedAnalysisFEN);
        savedAnalysisFEN = '';
      }

      // Legg til denne linjen for √• sikre at brettet alltid er riktig vei i analysemodus
      board.orientation('white');

      // Restore board title
      if (loadedGame) {
        document.getElementById('boardTitle').textContent = `${loadedGame.white} vs ${loadedGame.black}`;
      } else {
        document.getElementById('boardTitle').textContent = 'Partianalyse';
      }

      console.log('Exited puzzle mode');
    }

    // Handle piece drops on the board
    function handlePieceDrop(source, target, piece, newPos, oldPos, orientation) {
      // If not in puzzle mode, prevent all moves (analysis mode)
      if (!isInPuzzleMode) {
        return 'snapback';
      }

      // In puzzle mode, check if the move is correct
      const playerMove = source + target;
      const expectedMove = puzzleSolutionMoves[currentPuzzleStep * 2 + 1];

      console.log('Player move:', playerMove, 'Expected:', expectedMove);

      if (expectedMove && (playerMove === expectedMove || playerMove === expectedMove.substring(0, 4))) {
        // CORRECT MOVE
        console.log('Correct move!');

        // Execute the move in the game engine
        const move = game.move({
          from: source,
          to: target,
          promotion: expectedMove.length > 4 ? expectedMove[4] : undefined
        });

        if (move) {
          // Highlight the correct move with green
          highlightMove(source, target, 'green', 2000);

          currentPuzzleStep++;

          // Check if puzzle is complete
          if ((currentPuzzleStep * 2 + 1) >= puzzleSolutionMoves.length) {
            completePuzzle();
            return;
          }

          // If not complete, play opponent's response after 500ms
          setTimeout(() => {
            const opponentMove = puzzleSolutionMoves[currentPuzzleStep * 2];

            if (opponentMove) {
              const oppMove = game.move({
                from: opponentMove.substring(0, 2),
                to: opponentMove.substring(2, 4),
                promotion: opponentMove.length > 4 ? opponentMove[4] : undefined
              });

              if (oppMove) {
                board.position(game.fen());

                // Highlight opponent's move with yellow
                highlightMove(opponentMove.substring(0, 2), opponentMove.substring(2, 4), 'yellow', 2000);

                // Update board title for next move
                const playerColorName = game.turn() === 'w' ? 'hvit' : 'svart';
                const instruction = translateThemeToInstruction(currentPuzzle.Themes);
                document.getElementById('boardTitle').textContent = `Du spiller ${playerColorName}, kan du ${instruction}?`;
              }
            }
          }, 500);
        }

        return; // Allow the move
      } else {
        // WRONG MOVE
        console.log('Wrong move!');

        // Highlight the wrong square briefly
        highlightMove(source, source, 'red', 1000);

        // Update board title
        document.getElementById('boardTitle').textContent = "Feil, pr√∏v igjen!";

        return 'snapback'; // Snap piece back
      }
    }

    /********************* UI: kategorier & navigasjon *********************/
    function onTab(e){ const c=e.currentTarget.dataset.c; if(c===current) return; document.querySelectorAll('.tab').forEach(b=>b.setAttribute('aria-selected', String(b===e.currentTarget))); loadCategory(c); }
    function loadCategory(category){ current=category; dkOn=false; document.getElementById('dkart').hidden=true; const title=document.getElementById('boardTitle'); const names={opening:'√Öpningsanalyse',tactics:'Taktisk analyse',strategy:'Strategisk analyse',endgame:'Sluttspillsanalyse',skills:'Kjerneferdighetstrening'}; if(!loadedGame){ title.textContent=names[category]||'Partianalyse'; game=new Chess(); sanList=[]; idx=0; board.position('start'); renderMoveList(); updateButtons(); } else { title.textContent=`${loadedGame.white} vs ${loadedGame.black}`; } }

    function renderMoveList(){
      const list=document.getElementById('moveList');
      list.innerHTML='';

      if(sanList.length===0){
        list.innerHTML='<div style="padding:20px;text-align:center;color:var(--muted);">Ingen parti lastet.<br>Bruk PGN‚Äëknappen.</div>';
        return;
      }


      for(let i=0;i<sanList.length;i+=2){
        const rn=Math.floor(i/2)+1; const row=document.createElement('div'); row.className='ply';
        const num=document.createElement('strong'); num.textContent=rn+'.'; row.appendChild(num);
        const w=document.createElement('button'); w.type='button'; w.className='san'; w.textContent=sanList[i]; w.dataset.i=i; w.addEventListener('click',()=>goTo(i+1));
        if(evaluations[i+1]){
          const ev=document.createElement('span');
          ev.className='eval';
          const cls=getEvalClass(evaluations[i+1]);
          if(cls) ev.classList.add(cls);
          ev.textContent=evaluations[i+1];

          // Add source indicator
          if(enhancedEvals[i+1]) {
            const source = enhancedEvals[i+1].source;
            if(source === 'Opening') {
              ev.style.borderBottom = '2px solid var(--primary)';
              ev.title = '√Öpningsbok-evaluering';
              if(enhancedEvals[i+1].stats) {
                ev.title += `\n${enhancedEvals[i+1].stats.totalGames} partier`;
              }
            } else if(source === 'PGN') {
              ev.style.borderBottom = '2px solid var(--accent)';
              ev.title = 'PGN-evaluering';
            } else if(source === 'Stockfish') {
              ev.style.borderBottom = '2px solid var(--ok)';
              ev.title = 'Stockfish-evaluering';
            }
          }
          w.appendChild(ev);
        }
        row.appendChild(w);
        if(sanList[i+1]){
          const b=document.createElement('button');
          b.type='button';
          b.className='san';
          b.textContent=sanList[i+1];
          b.dataset.i=i+1;
          b.addEventListener('click',()=>goTo(i+2));

          if(evaluations[i+2]){
            const ev2=document.createElement('span');
            ev2.className='eval';
            const cls2=getEvalClass(evaluations[i+2]);
            if(cls2) ev2.classList.add(cls2);
            ev2.textContent=evaluations[i+2];

            // Add source indicator for black move
            if(enhancedEvals[i+2]) {
              const source = enhancedEvals[i+2].source;
              if(source === 'Opening') {
                ev2.style.borderBottom = '2px solid var(--primary)';
                ev2.title = '√Öpningsbok-evaluering';
                if(enhancedEvals[i+2].stats) {
                  ev2.title += `\n${enhancedEvals[i+2].stats.totalGames} partier`;
                }
              } else if(source === 'PGN') {
                ev2.style.borderBottom = '2px solid var(--accent)';
                ev2.title = 'PGN-evaluering';
              } else if(source === 'Stockfish') {
                ev2.style.borderBottom = '2px solid var(--ok)';
                ev2.title = 'Stockfish-evaluering';
              }
            }
            b.appendChild(ev2);
          }
          row.appendChild(b);
        }
        list.appendChild(row);
      }
      highlightActive();
			renderEvalGraph();      // tegn/oppdater grafen n√•r trekklisten oppdateres
			updateEvalNowMarker();  // plasser "n√•"-mark√∏r i grafen
      if(window.matchMedia('(max-width:760px)').matches){ document.getElementById('panelToggle').style.display='inline-flex'; } else { document.getElementById('panelToggle').style.display='none'; document.getElementById('overlay').classList.remove('show'); document.getElementById('sidepanel').classList.remove('open'); }
    }

    function highlightActive(){ document.querySelectorAll('.san').forEach(b=>b.classList.remove('active')); const activeIndex=idx-1; if(activeIndex>=0){ const btn=document.querySelector(`.san[data-i="${activeIndex}"]`); if(btn) btn.classList.add('active'); } ensureActiveVisible(); }

    function ensureActiveVisible(){ const list=document.getElementById('moveList'); const btn=list.querySelector('.san.active'); if(!btn) return; const lr=list.getBoundingClientRect(); const br=btn.getBoundingClientRect(); if(br.top<lr.top){ list.scrollTop -= (lr.top - br.top) + btn.offsetHeight; } else if(br.bottom>lr.bottom){ list.scrollTop += (br.bottom - lr.bottom) + btn.offsetHeight; } }

		function parseEvalToNumber(evStr) {
			if (!evStr) return 0;
			const s = String(evStr).trim();

			// Mate (#¬±n)
			if (s.startsWith('#')) {
				// '#-3' => -10, '#5'/'#+5' => +10
				return s.includes('-') ? -10.0 : 10.0;
			}
			// Alternativ "M¬±n"
			const m = s.match(/^M(-?\d+)$/i);
			if (m) return parseInt(m[1], 10) < 0 ? -10.0 : 10.0;

			// Numerisk
			const n = Number(s);
			return Number.isFinite(n) ? n : 0;
		}

		// Gir SAN med trekknummer, og "..." for svart (som i tooltip-kravet)
		function prettyMoveLabel(plyIndex, sanList) {
			if (plyIndex <= 0) return '0. start';
			const moveNum = Math.ceil(plyIndex / 2);
			const isWhite = (plyIndex % 2 === 1);
			const san = sanList[plyIndex - 1] || '?';
			return isWhite ? `${moveNum}. ${san}` : `${moveNum}‚Ä¶ ${san}`;
		}

		// Tegn eval-grafen
		function renderEvalGraph() {
			const host = document.getElementById('evalGraph');
			if (!host) return;

			// Tomt eller ingen parti
			if (!Array.isArray(evaluations) || evaluations.length === 0 || !Array.isArray(sanList)) {
				host.innerHTML = '<div style="padding:8px;color:var(--muted);font-size:12px;text-align:center;">(ingen evaluering tilgjengelig)</div>';
				return;
			}

			// Bygg tallserie i "pawns" for alle posisjoner (0=startpos)
			const vals = evaluations.map(parseEvalToNumber);

			// For sikkerhets skyld: fyll manglende med siste kjente
			for (let i = 1; i < vals.length; i++) {
				if (!Number.isFinite(vals[i])) vals[i] = vals[i - 1];
			}

			const N = vals.length;
			if (N < 2) {
				host.innerHTML = '';
				return;
			}

			// Finn y-skala (symmetrisk)
			const absMax = Math.max(1.0, ...vals.map(v => Math.abs(v)));
			// Dempe ekstreme outliers s√• kurven holder seg lesbar
			const yMax = Math.min(Math.max(absMax, 3.0), 8.0);

			// Tegne-boks
			const W = host.clientWidth || 480;
			const H = 140;
			const padL = 6, padR = 6, padT = 6, padB = 6;
			const innerW = Math.max(1, W - padL - padR);
			const innerH = Math.max(1, H - padT - padB);

			// Skalaer
			const xOf = i => padL + (innerW * i) / (N - 1);
			const yOf = v => padT + (innerH * (1 - ((v + yMax) / (2 * yMax)))); // 0-linje midt i (v=0 ‚áí midt)

			// Bygg path for kurve
			let d = '';
			for (let i = 0; i < N; i++) {
				const x = xOf(i), y = yOf(vals[i]);
				d += (i === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
			}

			// Areal over og under 0.0 (midtlinjen)
			const yZero = yOf(0);
			const areaPos = `M ${xOf(0)} ${yZero}` +
											vals.map((v, i) => ` L ${xOf(i)} ${Math.min(yZero, yOf(v))}`).join('') +
											` L ${xOf(N-1)} ${yZero} Z`;
			const areaNeg = `M ${xOf(0)} ${yZero}` +
											vals.map((v, i) => ` L ${xOf(i)} ${Math.max(yZero, yOf(v))}`).join('') +
											` L ${xOf(N-1)} ${yZero} Z`;

			// Punkter (vi bruker dem til hover/klikk; visuelt er de diskrete)
			const circles = [];
			for (let i = 0; i < N; i++) {
				const x = xOf(i), y = yOf(vals[i]);
				circles.push(`<circle class="pt" r="3" cx="${x}" cy="${y}" data-i="${i}" />`);
			}

			// SVG
			host.innerHTML = `
				<svg viewBox="0 0 ${W} ${H}" preserveAspectRatio="none" aria-hidden="false" role="img">
					<line class="zero" x1="${padL}" y1="${yZero}" x2="${padL + innerW}" y2="${yZero}"></line>
					<path class="area-pos" d="${areaPos}"></path>
					<path class="area-neg" d="${areaNeg}"></path>
					<path class="curve" d="${d}"></path>
					<g class="points">${circles.join('')}</g>
					<line class="now" id="evalNowLine" x1="${xOf(idx)}" y1="${padT}" x2="${xOf(idx)}" y2="${padT + innerH}"></line>
				</svg>
			`;

			// Tooltip
			let tip;
			const ensureTip = () => {
				if (!tip) {
					tip = document.createElement('div');
					tip.className = 'eval-tooltip';
					document.body.appendChild(tip);
				}
				return tip;
			};

			const svg = host.querySelector('svg');
			const pts = host.querySelectorAll('.pt');

			// Hover + klikk
			pts.forEach(pt => {
				pt.addEventListener('mousemove', (e) => {
					const i = Number(pt.getAttribute('data-i') || '0');
					const label = prettyMoveLabel(i, sanList);     // linje 1
					const evStr = evaluations[i] || '0.0';         // linje 2
					const t = ensureTip();
					t.innerHTML = `${label}<br/>Eval: ${evStr}`;
					t.style.left = (e.clientX + 10) + 'px';
					t.style.top  = (e.clientY - 16) + 'px';
					t.style.display = 'block';
				});
				pt.addEventListener('mouseleave', () => {
					if (tip) tip.style.display = 'none';
				});
				pt.addEventListener('click', () => {
					const i = Number(pt.getAttribute('data-i') || '0');
					// G√• til posisjonen ETTER dette trekket (i == 0 er startpos)
					goTo(i);
				});
			});
		}

		// Flytt ‚Äún√•-mark√∏r‚Äù n√•r idx endres (uten √• tegne grafen p√• nytt)
		function updateEvalNowMarker() {
			const host = document.getElementById('evalGraph');
			if (!host) return;
			const svg = host.querySelector('svg');
			const line = host.querySelector('#evalNowLine');
			if (!svg || !line || !Array.isArray(evaluations) || evaluations.length === 0) return;

			const W = svg.viewBox.baseVal.width;
			const H = svg.viewBox.baseVal.height;
			const padL = 6, padR = 6, padT = 6, padB = 6;
			const innerW = Math.max(1, W - padL - padR);
			const N = evaluations.length;

			const xOf = i => padL + (innerW * i) / (N - 1);
			const x = xOf(Math.max(0, Math.min(idx, N - 1)));

			line.setAttribute('x1', x);
			line.setAttribute('x2', x);
		}

    function getEvalClass(evalStr) {
      if (!evalStr) return null;
      const str = String(evalStr);

      // Mate: se etter M¬±n
      const mateMatch = str.match(/M(-?\d+)/i);
      if (mateMatch) {
        const n = parseInt(mateMatch[1], 10);
        return n < 0 ? 'negative' : 'positive';
      }

      // Numerisk evaluering
      const numMatch = str.match(/^[+\-]?(\d+(?:\.\d+)?)$/);
      if (numMatch) {
        const val = parseFloat(str);
        if (val > 0.5) return 'positive';
        if (val < -0.5) return 'negative';
      }

      return null;
    }

    function nextMove(){ if(idx>=sanList.length) return; game.move(sanList[idx]); idx++; board.position(game.fen()); highlightActive(); if(dkOn) drawDkart(); updateButtons(); scrollToKeyMoment(idx); updateDynamicOpeningInfo(); updateEvalNowMarker();}
    function prevMove(){ if(idx<=0) return; idx--; game.reset(); for(let i=0;i<idx;i++) game.move(sanList[i]); board.position(game.fen()); highlightActive(); if(dkOn) drawDkart(); updateButtons(); scrollToKeyMoment(idx); updateDynamicOpeningInfo(); updateEvalNowMarker();}
    function goTo(n){ idx=Math.max(0, Math.min(n, sanList.length)); game.reset(); for(let i=0;i<idx;i++) game.move(sanList[i]); board.position(game.fen()); highlightActive(); if(dkOn) drawDkart(); updateButtons(); scrollToKeyMoment(idx); updateDynamicOpeningInfo(); updateEvalNowMarker();}

    function scrollToKeyMoment(moveIndex){
      const box=document.getElementById('explainBox');
      if(!box) return;

      const headers=box.querySelectorAll('h3');
      if(headers.length===0) return;

      // Fix move number and color calculation
      if(moveIndex === 0) return; // Startposisjon, ingen auto-scroll

      // Beregn hvilket trekk som ER utf√∏rt (ikke neste trekk)
      // moveIndex=1 = 1 trekk utf√∏rt (1.e4), moveIndex=2 = 2 trekk utf√∏rt (1.e4 e5)
      const moveNumber = Math.ceil(moveIndex / 2);
      const isWhiteMove = (moveIndex % 2 === 1);
      const color = isWhiteMove ? 'Hvit' : 'Svart';

      console.log(`Auto-scroll: moveIndex=${moveIndex}, moveNumber=${moveNumber}, color=${color}`);

      let target = null;

      // S√∏k gjennom headers med bedre matching
      for(const header of headers) {
        const text = header.textContent || '';
        console.log(`Checking header: "${text}"`);

        // Match ny format: "### N√∏kkel√∏yeblikk X (Trekk Y. MOVE):" hvor MOVE er faktisk trekk
        let match = text.match(/N√∏kkel√∏yeblikk\s+\d+\s*\(Trekk\s+(\d+)\.\s*([^):]+)\)/i);
        if(match) {
          const headerMoveNum = parseInt(match[1], 10);
          const headerMove = match[2].trim();

          console.log(`Found: Move ${headerMoveNum}, Notation: ${headerMove}`);

          // For ny format, sjekk om trekknummer stemmer og at dette er det riktige trekket
          if(headerMoveNum === moveNumber) {
            const expectedMove = sanList[moveIndex-1];
            if(expectedMove && headerMove === expectedMove) {
              target = header;
              console.log(`‚úÖ Match found for Move ${moveNumber} (${expectedMove})`);
              break;
            }
          }
        }

        // Fallback: Match gammelt format: "### N√∏kkel√∏yeblikk X (Trekk Y. [Farge]):"
        match = text.match(/N√∏kkel√∏yeblikk\s+\d+\s*\(Trekk\s+(\d+)\.\s*\[([^\]]+)\]/i);
        if(match) {
          const headerMoveNum = parseInt(match[1], 10);
          const headerColor = match[2].trim();

          console.log(`Found old format: Move ${headerMoveNum}, Color ${headerColor}`);

          if(headerMoveNum === moveNumber && headerColor.toLowerCase() === color.toLowerCase()) {
            target = header;
            console.log(`‚úÖ Match found for Move ${moveNumber} (${color})`);
            break;
          }
        }
      }

      if(target) {
        // Forbedret scroll-posisjonering som tar hensyn til container bounds
        const containerRect = box.getBoundingClientRect();
        const targetRect = target.getBoundingClientRect();

        // Beregn relativ posisjon innenfor containeren
        const relativeTop = targetRect.top - containerRect.top + box.scrollTop;
        const desiredScrollTop = relativeTop - 20; // 20px margin fra topp

        // S√∏rg for at vi ikke pr√∏ver √• scrolle utenfor bounds
        const maxScroll = box.scrollHeight - box.clientHeight;
        const finalScrollTop = Math.max(0, Math.min(desiredScrollTop, maxScroll));

        box.scrollTo({
          top: finalScrollTop,
          behavior: 'smooth'
        });

        console.log(`‚úÖ Scrolled to key moment: Move ${moveNumber} (${color}) at scroll position ${finalScrollTop}`);

        // Visuell feedback (blink effect) med forbedret styling
        target.style.transition = 'background-color 0.3s ease';
        target.style.backgroundColor = 'rgba(79, 124, 255, 0.2)';
        target.style.borderLeft = '4px solid var(--primary)';
        target.style.paddingLeft = '8px';

        setTimeout(() => {
          target.style.backgroundColor = '';
          target.style.borderLeft = '';
          target.style.paddingLeft = '';
        }, 2000);
      } else {
        console.log(`‚ùå No key moment found for Move ${moveNumber} (${color})`);
      }
    }

    function resetPosition(){
      idx=0;
      game.reset();
      board.position('start');
      highlightActive();
      if(dkOn) drawDkart();
      updateButtons();
      updateEvalNowMarker();
    }
    function goToEnd() { goTo(sanList.length); }
    function updateButtons(){ document.getElementById('btnPrev').disabled=(idx===0); document.getElementById('btnNext').disabled=(idx===sanList.length); }

    /********************* Lichess analyse‚Äëlenke *********************/
    function openLichessAnalysis(){ const fen=(game&&game.fen)? game.fen().replace(/ /g,'_') : 'start'; window.open(`https://lichess.org/analysis/${fen}`,'_blank'); }

    /********************* DKART *********************/
    function toggleDkart(){ dkOn=!dkOn; document.getElementById('btnDkart').setAttribute('aria-pressed',dkOn); const el=document.getElementById('dkart'); el.hidden=!dkOn; if(dkOn) drawDkart(); }
    function drawDkart(){ const overlay=document.getElementById('dkart'); overlay.innerHTML=''; const rect=document.getElementById('board').getBoundingClientRect(); const s=rect.width/8; const grid=dominanceGrid(game.fen()); for(let r=0;r<8;r++){ for(let c=0;c<8;c++){ const v=Math.max(-3,Math.min(3,grid[r][c])); const d=document.createElement('div'); d.className=`dk-square dk-${v}`; d.style.left=(c*s)+'px'; d.style.top=(r*s)+'px'; d.style.width=s+'px'; d.style.height=s+'px'; d.textContent = v===0? '' : (v>0?`+${v}`:`${v}`); overlay.appendChild(d); } } }
    function dominanceGrid(fen){ const pos=parseFEN(fen); const g=Array.from({length:8},()=>Array(8).fill(0)); for(let r=0;r<8;r++){ for(let c=0;c<8;c++){ let w=0,b=0; for(const p of pos.white){ if(canAttack(p,{row:r,col:c},pos)) w++; } for(const p of pos.black){ if(canAttack(p,{row:r,col:c},pos)) b++; } g[r][c]=w-b; } } return g; }
    function parseFEN(fen){ const boardPart=fen.split(' ')[0]; const rows=boardPart.split('/'); const P={white:[],black:[]}; for(let r=0;r<8;r++){ let c=0; for(const ch of rows[r]){ if(/\d/.test(ch)) c += parseInt(ch,10); else { const piece={type:ch.toLowerCase(),row:r,col:c,color:/[A-Z]/.test(ch)?'white':'black'}; P[piece.color].push(piece); c++; } } } return P; }
    function canAttack(piece,target,pos){ const dx=target.col-piece.col, dy=target.row-piece.row; switch(piece.type){ case 'p':{ const dir=piece.color==='white'?-1:1; return dy===dir && Math.abs(dx)===1; } case 'r':{ if(dx===0||dy===0) return clearLine(piece,target,pos); return false; } case 'n': return (Math.abs(dx)===2&&Math.abs(dy)===1)||(Math.abs(dx)===1&&Math.abs(dy)===2); case 'b':{ if(Math.abs(dx)===Math.abs(dy)) return clearLine(piece,target,pos); return false; } case 'q':{ if(dx===0||dy===0||Math.abs(dx)===Math.abs(dy)) return clearLine(piece,target,pos); return false; } case 'k': return Math.abs(dx)<=1 && Math.abs(dy)<=1; default: return false; } }
    function clearLine(from,to,pos){ const dx=Math.sign(to.col-from.col), dy=Math.sign(to.row-from.row); let r=from.row+dy, c=from.col+dx; const all=[...pos.white,...pos.black]; while(r!==to.row || c!==to.col){ if(all.some(p=>p.row===r&&p.col===c)) return false; r+=dy; c+=dx; } return true; }

    document.addEventListener('DOMContentLoaded',init);
  </script>
</body>
</html>
